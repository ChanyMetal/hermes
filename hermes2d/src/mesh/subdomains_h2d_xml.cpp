// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "subdomains_h2d_xml.h"

namespace XMLSubdomains
{
  // domain
  // 

  const domain::variables_type& domain::
  variables () const
  {
    return this->variables_.get ();
  }

  domain::variables_type& domain::
  variables ()
  {
    return this->variables_.get ();
  }

  void domain::
  variables (const variables_type& x)
  {
    this->variables_.set (x);
  }

  void domain::
  variables (::std::auto_ptr< variables_type > x)
  {
    this->variables_.set (x);
  }

  const domain::vertices_type& domain::
  vertices () const
  {
    return this->vertices_.get ();
  }

  domain::vertices_type& domain::
  vertices ()
  {
    return this->vertices_.get ();
  }

  void domain::
  vertices (const vertices_type& x)
  {
    this->vertices_.set (x);
  }

  void domain::
  vertices (::std::auto_ptr< vertices_type > x)
  {
    this->vertices_.set (x);
  }

  const domain::elements_type& domain::
  elements () const
  {
    return this->elements_.get ();
  }

  domain::elements_type& domain::
  elements ()
  {
    return this->elements_.get ();
  }

  void domain::
  elements (const elements_type& x)
  {
    this->elements_.set (x);
  }

  void domain::
  elements (::std::auto_ptr< elements_type > x)
  {
    this->elements_.set (x);
  }

  const domain::boundaries_type& domain::
  boundaries () const
  {
    return this->boundaries_.get ();
  }

  domain::boundaries_type& domain::
  boundaries ()
  {
    return this->boundaries_.get ();
  }

  void domain::
  boundaries (const boundaries_type& x)
  {
    this->boundaries_.set (x);
  }

  void domain::
  boundaries (::std::auto_ptr< boundaries_type > x)
  {
    this->boundaries_.set (x);
  }

  const domain::curves_type& domain::
  curves () const
  {
    return this->curves_.get ();
  }

  domain::curves_type& domain::
  curves ()
  {
    return this->curves_.get ();
  }

  void domain::
  curves (const curves_type& x)
  {
    this->curves_.set (x);
  }

  void domain::
  curves (::std::auto_ptr< curves_type > x)
  {
    this->curves_.set (x);
  }

  const domain::subdomains_type& domain::
  subdomains () const
  {
    return this->subdomains_.get ();
  }

  domain::subdomains_type& domain::
  subdomains ()
  {
    return this->subdomains_.get ();
  }

  void domain::
  subdomains (const subdomains_type& x)
  {
    this->subdomains_.set (x);
  }

  void domain::
  subdomains (::std::auto_ptr< subdomains_type > x)
  {
    this->subdomains_.set (x);
  }


  // subdomains
  // 

  const subdomains::subdomain_sequence& subdomains::
  subdomain () const
  {
    return this->subdomain_;
  }

  subdomains::subdomain_sequence& subdomains::
  subdomain ()
  {
    return this->subdomain_;
  }

  void subdomains::
  subdomain (const subdomain_sequence& s)
  {
    this->subdomain_ = s;
  }


  // subdomain
  // 

  const subdomain::element_number_sequence& subdomain::
  element_number () const
  {
    return this->element_number_;
  }

  subdomain::element_number_sequence& subdomain::
  element_number ()
  {
    return this->element_number_;
  }

  void subdomain::
  element_number (const element_number_sequence& s)
  {
    this->element_number_ = s;
  }

  const subdomain::boundary_edge_number_sequence& subdomain::
  boundary_edge_number () const
  {
    return this->boundary_edge_number_;
  }

  subdomain::boundary_edge_number_sequence& subdomain::
  boundary_edge_number ()
  {
    return this->boundary_edge_number_;
  }

  void subdomain::
  boundary_edge_number (const boundary_edge_number_sequence& s)
  {
    this->boundary_edge_number_ = s;
  }

  const subdomain::name_type& subdomain::
  name () const
  {
    return this->name_.get ();
  }

  subdomain::name_type& subdomain::
  name ()
  {
    return this->name_.get ();
  }

  void subdomain::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void subdomain::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }


  // element_number
  // 

  const element_number::number_type& element_number::
  number () const
  {
    return this->number_.get ();
  }

  element_number::number_type& element_number::
  number ()
  {
    return this->number_.get ();
  }

  void element_number::
  number (const number_type& x)
  {
    this->number_.set (x);
  }


  // boundary_edge_number
  // 

  const boundary_edge_number::number_type& boundary_edge_number::
  number () const
  {
    return this->number_.get ();
  }

  boundary_edge_number::number_type& boundary_edge_number::
  number ()
  {
    return this->number_.get ();
  }

  void boundary_edge_number::
  number (const number_type& x)
  {
    this->number_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace XMLSubdomains
{
  // domain
  //

  domain::
  domain (const variables_type& variables,
          const vertices_type& vertices,
          const elements_type& elements,
          const boundaries_type& boundaries,
          const curves_type& curves,
          const subdomains_type& subdomains)
  : ::xml_schema::type (),
    variables_ (variables, ::xml_schema::flags (), this),
    vertices_ (vertices, ::xml_schema::flags (), this),
    elements_ (elements, ::xml_schema::flags (), this),
    boundaries_ (boundaries, ::xml_schema::flags (), this),
    curves_ (curves, ::xml_schema::flags (), this),
    subdomains_ (subdomains, ::xml_schema::flags (), this)
  {
  }

  domain::
  domain (::std::auto_ptr< variables_type >& variables,
          ::std::auto_ptr< vertices_type >& vertices,
          ::std::auto_ptr< elements_type >& elements,
          ::std::auto_ptr< boundaries_type >& boundaries,
          ::std::auto_ptr< curves_type >& curves,
          ::std::auto_ptr< subdomains_type >& subdomains)
  : ::xml_schema::type (),
    variables_ (variables, ::xml_schema::flags (), this),
    vertices_ (vertices, ::xml_schema::flags (), this),
    elements_ (elements, ::xml_schema::flags (), this),
    boundaries_ (boundaries, ::xml_schema::flags (), this),
    curves_ (curves, ::xml_schema::flags (), this),
    subdomains_ (subdomains, ::xml_schema::flags (), this)
  {
  }

  domain::
  domain (const domain& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    variables_ (x.variables_, f, this),
    vertices_ (x.vertices_, f, this),
    elements_ (x.elements_, f, this),
    boundaries_ (x.boundaries_, f, this),
    curves_ (x.curves_, f, this),
    subdomains_ (x.subdomains_, f, this)
  {
  }

  domain::
  domain (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    variables_ (f, this),
    vertices_ (f, this),
    elements_ (f, this),
    boundaries_ (f, this),
    curves_ (f, this),
    subdomains_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void domain::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variables
      //
      if (n.name () == "variables" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< variables_type > r (
          variables_traits::create (i, f, this));

        if (!variables_.present ())
        {
          this->variables_.set (r);
          continue;
        }
      }

      // vertices
      //
      if (n.name () == "vertices" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< vertices_type > r (
          vertices_traits::create (i, f, this));

        if (!vertices_.present ())
        {
          this->vertices_.set (r);
          continue;
        }
      }

      // elements
      //
      if (n.name () == "elements" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< elements_type > r (
          elements_traits::create (i, f, this));

        if (!elements_.present ())
        {
          this->elements_.set (r);
          continue;
        }
      }

      // boundaries
      //
      if (n.name () == "boundaries" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< boundaries_type > r (
          boundaries_traits::create (i, f, this));

        if (!boundaries_.present ())
        {
          this->boundaries_.set (r);
          continue;
        }
      }

      // curves
      //
      if (n.name () == "curves" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< curves_type > r (
          curves_traits::create (i, f, this));

        if (!curves_.present ())
        {
          this->curves_.set (r);
          continue;
        }
      }

      // subdomains
      //
      if (n.name () == "subdomains" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< subdomains_type > r (
          subdomains_traits::create (i, f, this));

        if (!subdomains_.present ())
        {
          this->subdomains_.set (r);
          continue;
        }
      }

      break;
    }

    if (!variables_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "variables",
        "");
    }

    if (!vertices_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "vertices",
        "");
    }

    if (!elements_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "elements",
        "");
    }

    if (!boundaries_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boundaries",
        "");
    }

    if (!curves_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "curves",
        "");
    }

    if (!subdomains_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "subdomains",
        "");
    }
  }

  domain* domain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class domain (*this, f, c);
  }

  domain::
  ~domain ()
  {
  }

  // subdomains
  //

  subdomains::
  subdomains ()
  : ::xml_schema::type (),
    subdomain_ (::xml_schema::flags (), this)
  {
  }

  subdomains::
  subdomains (const subdomains& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    subdomain_ (x.subdomain_, f, this)
  {
  }

  subdomains::
  subdomains (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    subdomain_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void subdomains::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // subdomain
      //
      if (n.name () == "subdomain" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< subdomain_type > r (
          subdomain_traits::create (i, f, this));

        this->subdomain_.push_back (r);
        continue;
      }

      break;
    }
  }

  subdomains* subdomains::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class subdomains (*this, f, c);
  }

  subdomains::
  ~subdomains ()
  {
  }

  // subdomain
  //

  subdomain::
  subdomain (const name_type& name)
  : ::xml_schema::type (),
    element_number_ (::xml_schema::flags (), this),
    boundary_edge_number_ (::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this)
  {
  }

  subdomain::
  subdomain (const subdomain& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    element_number_ (x.element_number_, f, this),
    boundary_edge_number_ (x.boundary_edge_number_, f, this),
    name_ (x.name_, f, this)
  {
  }

  subdomain::
  subdomain (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    element_number_ (f, this),
    boundary_edge_number_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void subdomain::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // element-number
      //
      if (n.name () == "element-number" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< element_number_type > r (
          element_number_traits::create (i, f, this));

        this->element_number_.push_back (r);
        continue;
      }

      // boundary_edge-number
      //
      if (n.name () == "boundary_edge-number" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< boundary_edge_number_type > r (
          boundary_edge_number_traits::create (i, f, this));

        this->boundary_edge_number_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  subdomain* subdomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class subdomain (*this, f, c);
  }

  subdomain::
  ~subdomain ()
  {
  }

  // element_number
  //

  element_number::
  element_number (const number_type& number)
  : ::xml_schema::type (),
    number_ (number, ::xml_schema::flags (), this)
  {
  }

  element_number::
  element_number (const element_number& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    number_ (x.number_, f, this)
  {
  }

  element_number::
  element_number (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    number_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void element_number::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "number",
        "");
    }
  }

  element_number* element_number::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class element_number (*this, f, c);
  }

  element_number::
  ~element_number ()
  {
  }

  // boundary_edge_number
  //

  boundary_edge_number::
  boundary_edge_number (const number_type& number)
  : ::xml_schema::type (),
    number_ (number, ::xml_schema::flags (), this)
  {
  }

  boundary_edge_number::
  boundary_edge_number (const boundary_edge_number& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    number_ (x.number_, f, this)
  {
  }

  boundary_edge_number::
  boundary_edge_number (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    number_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void boundary_edge_number::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "number",
        "");
    }
  }

  boundary_edge_number* boundary_edge_number::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class boundary_edge_number (*this, f, c);
  }

  boundary_edge_number::
  ~boundary_edge_number ()
  {
  }
}

#include <ostream>

namespace XMLSubdomains
{
  ::std::ostream&
  operator<< (::std::ostream& o, const domain& i)
  {
    o << ::std::endl << "variables: " << i.variables ();
    o << ::std::endl << "vertices: " << i.vertices ();
    o << ::std::endl << "elements: " << i.elements ();
    o << ::std::endl << "boundaries: " << i.boundaries ();
    o << ::std::endl << "curves: " << i.curves ();
    o << ::std::endl << "subdomains: " << i.subdomains ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const subdomains& i)
  {
    for (subdomains::subdomain_const_iterator
         b (i.subdomain ().begin ()), e (i.subdomain ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "subdomain: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const subdomain& i)
  {
    for (subdomain::element_number_const_iterator
         b (i.element_number ().begin ()), e (i.element_number ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "element-number: " << *b;
    }

    for (subdomain::boundary_edge_number_const_iterator
         b (i.boundary_edge_number ().begin ()), e (i.boundary_edge_number ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "boundary_edge-number: " << *b;
    }

    o << ::std::endl << "name: " << i.name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const element_number& i)
  {
    o << ::std::endl << "number: " << i.number ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const boundary_edge_number& i)
  {
    o << ::std::endl << "number: " << i.number ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace XMLSubdomains
{
  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::XMLSubdomains::domain > r (
      ::XMLSubdomains::domain_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLSubdomains::domain > r (
      ::XMLSubdomains::domain_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLSubdomains::domain > r (
      ::XMLSubdomains::domain_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLSubdomains::domain_ (isrc, f, p);
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLSubdomains::domain_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLSubdomains::domain_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLSubdomains::domain_ (isrc, f, p);
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLSubdomains::domain_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLSubdomains::domain_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::XMLSubdomains::domain > r (
      ::XMLSubdomains::domain_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLSubdomains::domain > r (
      ::XMLSubdomains::domain_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLSubdomains::domain > r (
      ::XMLSubdomains::domain_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::XMLSubdomains::domain > r (
        ::XMLSubdomains::domain_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "domain" &&
        n.namespace_ () == "XMLSubdomains")
    {
      ::std::auto_ptr< ::XMLSubdomains::domain > r (
        ::xsd::cxx::tree::traits< ::XMLSubdomains::domain, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "domain",
      "XMLSubdomains");
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "domain" &&
        n.namespace_ () == "XMLSubdomains")
    {
      ::std::auto_ptr< ::XMLSubdomains::domain > r (
        ::xsd::cxx::tree::traits< ::XMLSubdomains::domain, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "domain",
      "XMLSubdomains");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

