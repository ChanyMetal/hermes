<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Hermes2D Tutorial: Part I (Linear Problems) &mdash; Hermes2D Documentation</title>
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Hermes2D Documentation" href="../../index.html" />
    <link rel="next" title="Hermes2D Tutorial: Part II (Automatic Adaptivity)" href="tutorial-2.html" />
    <link rel="prev" title="How to Submit Your First Pull Request" href="../first_pull_request.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial-2.html" title="Hermes2D Tutorial: Part II (Automatic Adaptivity)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../first_pull_request.html" title="How to Submit Your First Pull Request"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">Content</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="hermes2d-tutorial-part-i-linear-problems">
<h1>Hermes2D Tutorial: Part I (Linear Problems)<a class="headerlink" href="#hermes2d-tutorial-part-i-linear-problems" title="Permalink to this headline">¶</a></h1>
<p>This tutorial should give you a good idea of how Hermes works. It begins with eight
sections related to Hermes2D (six tutorial sections, benchmarks, and examples).
Then we discuss selected examples for Hermes1D and several benchmarks and examples
for Hermes3D.</p>
<p>After reading the tutorial, you will be able to create your own applications and/or
adjust existing Hermes examples for your
purposes. At the beginning of every section we give a reference to the corresponding example in the
Hermes git repository &#8211; there you will always find the corresponding main.cpp file, weak forms,
mesh file, etc.</p>
<p>This document is under continuous development and certainly it is not perfect.
If you find bugs, typos, dead links or such, help us improve it by reporting them
through one of the mailing lists for
<a class="reference external" href="http://groups.google.com/group/hermes1d/">Hermes1D</a>,
<a class="reference external" href="http://groups.google.com/group/hermes2d/">Hermes2D</a>, or
<a class="reference external" href="http://groups.google.com/group/hermes3d/">Hermes3D</a>.
We are looking forward to your feedback!</p>
<div class="section" id="finite-element-mesh-01">
<h2>Finite Element Mesh (01)<a class="headerlink" href="#finite-element-mesh-01" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/01-mesh">01-mesh</a>.</p>
<p>Every finite element computation starts with partitioning the domain
into a finite element mesh. Hermes uses (possibly curvilinear) triangles and
quadrilaterals that can be combined together in one mesh. While non-adaptive
or low-order finite element codes need fine initial meshes constructed using
specialized mesh generation software, in Hermes it usually suffices to
create a simple initial mesh and use a variety of built-in functions for
a-priori mesh refinement. In most cases, automatic adaptivity will take
care of the rest.</p>
<div align="center" class="align-center"><img alt="Sample finite element mesh." class="align-center" src="../../_images/simplemesh.png" style="width: 400px; height: 400px;" /></div>
<p>The domain in this example is defined via four macroelements &#8211; two
quadrilaterals and two curvilinear triangles. The elements are enumerated from 0 to 3.
One also needs to enumerate all mesh vertices and assign markers to all boundary edges.
Boundary markers are used to link boundary conditions with the boundary edges.</p>
<div class="section" id="mesh-file-format">
<h3>Mesh File Format<a class="headerlink" href="#mesh-file-format" title="Permalink to this headline">¶</a></h3>
<p>Hermes can read meshes in its own generic format as well as in the
<a class="reference external" href="http://sourceforge.net/projects/exodusii/">ExodusII</a> format
(this is, for example, the output of <a class="reference external" href="http://cubit.sandia.gov/">Cubit</a>).
First let us discuss the generic Hermes mesh data format. Reading
of ExodusII mesh files is very simple as we will see in example
<a class="reference external" href="http://hpfem.org/hermes/doc/src/hermes2d/examples.html#iron-water-neutronics">iron-water</a>.</p>
<p>Generic Hermes mesh file consists of variable assignments. Each variable can hold a real number,
list of real numbers, or list of lists. The following are all valid definitions in
the Hermes mesh file format:</p>
<div class="highlight-python"><pre># comments start with a hash
var = 5.0 + cos(pi)  # number
list = { 1, 2, 3, 4, var }  # list
pairs = { {1, 2}, {1, var}, {0, list} }  # list of lists</pre>
</div>
<p>Every mesh file must contain at least the variables <tt class="docutils literal"><span class="pre">vertices</span></tt>, <tt class="docutils literal"><span class="pre">elements</span></tt>
and <tt class="docutils literal"><span class="pre">boundaries</span></tt>. The variable <tt class="docutils literal"><span class="pre">vertices</span></tt> defines the coordinates
of all mesh vertices (in any order). In our case it looks like this:</p>
<div class="highlight-python"><pre>a = 1.0  # size of the mesh
b = sqrt(2)/2

vertices =
{
  { 0, -a },    # vertex 0
  { a, -a },    # vertex 1
  { -a, 0 },    # vertex 2
  { 0, 0 },     # vertex 3
  { a, 0 },     # vertex 4
  { -a, a },    # vertex 5
  { 0, a },     # vertex 6
  { a*b, a*b }  # vertex 7
}</pre>
</div>
<p>The variable <tt class="docutils literal"><span class="pre">elements</span></tt> defines all elements in the mesh via zero-based indices of their vertices in counter-clockwise order, plus an extra number denoting the element (material) marker. Element markers allow you to use different material parameters in areas with different material parameters. Moreover, Hermes allows you to assign different weak formulations to those areas, which can be very useful for some types of multiphysics problems. If the domain is composed of only one material, as in our case, all elements may be assigned a zero marker:</p>
<div class="highlight-python"><pre>elements =
{
  { 0, 1, 4, 3, 0 },  # quad 0
  { 3, 4, 7, 0 },     # tri 1
  { 3, 7, 6, 0 },     # tri 2
  { 2, 3, 6, 5, 0 }   # quad 3
}</pre>
</div>
<p>The last mandatory variable, <tt class="docutils literal"><span class="pre">boundaries</span></tt>, defines boundary markers for all
boundary edges. By default, all edges have zero markers. Only those with
positive markers are considered to be part of the domain boundary and can be
assigned a boundary condition, as we will see later. An edge is identified by
two vertex indices. In our case, we have</p>
<div class="highlight-python"><pre>boundaries =
{
  { 0, 1, 1 },
  { 1, 4, 2 },
  { 3, 0, 4 },
  { 4, 7, 2 },
  { 7, 6, 2 },
  { 2, 3, 4 },
  { 6, 5, 2 },
  { 5, 2, 3 }
}</pre>
</div>
<p>Finally, the file can also include the variable <tt class="docutils literal"><span class="pre">curves</span></tt>, which lists all
curved edges.  Each curved edge is described by one NURBS curve, defined by its
degree, control points and knot vector. Simplified syntax is available for
circular arcs.</p>
</div>
<div class="section" id="nurbs-curves">
<h3>NURBS Curves<a class="headerlink" href="#nurbs-curves" title="Permalink to this headline">¶</a></h3>
<p>Every NURBS curve is defined by its degree, control points with weights and the
knot vector. The degree <img class="math" src="../../_images/math/96ab646de7704969b91c76a214126b45f2b07b25.png" alt="d"/> is a positive integer, usually 1, 2, 3 or 5. Lines
and polylines are of degree 1, circles have degree 2 and free-form curves are
of degree 3 or 5. The control points <img class="math" src="../../_images/math/245a5501248a6ea24f520f76d4140cedf08e1674.png" alt="p_i"/>, <img class="math" src="../../_images/math/fa469fe90a1b149b4d21f25026cb6b00dd981a7d.png" alt="i = 0 \ldots n"/>, are the main tool for changing the
shape of the curve. A curve of degree <img class="math" src="../../_images/math/96ab646de7704969b91c76a214126b45f2b07b25.png" alt="d"/> must have at least <img class="math" src="../../_images/math/0d1a966b7f9f2cea85dc923e34961cc1ccd08cee.png" alt="d+1"/> control
points. In Hermes, the endpoints of the edge are always assumed to be the
first and last control points and therefore only the inner control points are
listed in the mesh file. There is a weight <img class="math" src="../../_images/math/eb14f863da3aba1b1e8daa15c3b903d8f567be4e.png" alt="w_i \geq 0"/> for every control point,
that influences the shape of the curve in its vicinity. If <img class="math" src="../../_images/math/ef628a2d09aa62302c35c0d8e97fa46f32328a4e.png" alt="w_i = 0"/> then
<img class="math" src="../../_images/math/245a5501248a6ea24f520f76d4140cedf08e1674.png" alt="p_i"/> has no effect on the shape.  As <img class="math" src="../../_images/math/535b2bfbb0a587e261a0d0af9b7b53e42629b14d.png" alt="w_i"/> increases, the curve is pulled
towards <img class="math" src="../../_images/math/245a5501248a6ea24f520f76d4140cedf08e1674.png" alt="p_i"/>.</p>
<p>The knot vector is a sequence of <img class="math" src="../../_images/math/4bea4f5ee837b0249288558f2fb73a871b264491.png" alt="m+1"/> values that determines how much and
where the control points influence the shape. The relation <img class="math" src="../../_images/math/8237bc058b56477d4a68ae7250919c617c1d6493.png" alt="m = n+d+1"/> must
hold. The sequence is nondecreasing, <img class="math" src="../../_images/math/032fb9c1ceac01a6656f6d3062b4809a5e084c2d.png" alt="t_i \leq t_{i+1}"/>, and divides the whole
interval <img class="math" src="../../_images/math/e861e10e1c19918756b9c8b7717684593c63aeb8.png" alt="[0,1]"/> into smaller intervals which determine the area of influence
of the control points. Since the curve has to start and end at the edge
vertices, the knot vector in Hermes always starts with <img class="math" src="../../_images/math/0d1a966b7f9f2cea85dc923e34961cc1ccd08cee.png" alt="d+1"/> zeros and ends
with <img class="math" src="../../_images/math/0d1a966b7f9f2cea85dc923e34961cc1ccd08cee.png" alt="d+1"/> ones. Only the inner knots are listed in the above definition of the
variable <tt class="docutils literal"><span class="pre">curves</span></tt>, where <img class="math" src="../../_images/math/7de182d21c4e61ede6c64b7ebcb8c177c15194d2.png" alt="knots"/> is a simple list of real values. For the
above example, we have</p>
<div class="highlight-python"><pre>curves =
{
  { 4, 7, 45 },  # +45 degree circular arcs
  { 7, 6, 45 }
}
# EOF</pre>
</div>
</div>
<div class="section" id="loading-mesh">
<h3>Loading Mesh<a class="headerlink" href="#loading-mesh" title="Permalink to this headline">¶</a></h3>
<p>As a &#8216;&#8217;Hello world&#8217;&#8217; example, let us load the mesh we have just created, and display it in a window.
Every main.cpp file in the git repository contains lots of comments and instructions. Skipping those,
the <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/tutorial/01-mesh/main.cpp">main.cpp</a>
file begins with creating an instance of the class Mesh. In order to load
the mesh file, you have to create a mesh loader class (in our case that is <tt class="docutils literal"><span class="pre">H2DReader</span></tt>) and
call the method <tt class="docutils literal"><span class="pre">load()</span></tt>:</p>
<div class="highlight-python"><pre>#include "hermes2d.h"

int main(int argc, char* argv[])
{
  // Load the mesh file.
  Mesh mesh;
  H2DReader mloader;
  mloader.load("domain.mesh", &amp;mesh);</pre>
</div>
<p>Note: To load the exodus-II mesh file, one has to use <tt class="docutils literal"><span class="pre">ExodusIIReader</span></tt> class instead.</p>
<p>The following portion of code illustrates various types of initial mesh refinements.
It does not matter if the mesh becomes irregular, in fact, arbitrarily irregular
meshes are at the heart of Hermes:</p>
<div class="highlight-python"><pre>// Perform some sample initial refinements.
mesh.refine_all_elements();          // refines all elements
mesh.refine_towards_vertex(3, 4);    // refines mesh towards
                                     // vertex #3 (4x)
mesh.refine_towards_boundary(2, 4);  // refines all elements
                                     // along boundary 2 (4x)
mesh.refine_element(86, 0);          // refines element #86
                                     // isotropically
mesh.refine_element(112, 0);         // refines element #112
                                     // isotropically
mesh.refine_element(84, 2);          // refines element #84
                                     // anisotropically
mesh.refine_element(114, 1);         // refines element #114
                                     // anisotropically</pre>
</div>
<p>Other ways of modifying meshes on the fly include:</p>
<div class="highlight-python"><pre>Mesh::refine_element(int id, int refinement = 0);
Mesh::convert_quads_to_triangles();
Mesh::convert_triangles_to_quads();
Mesh::refine_by_criterion(int (*criterion)(Element* e), int depth);
Mesh::refine_towards_vertex(int vertex_id, int depth);
Mesh::regularize(int n);
Mesh::unrefine_element(int id);
Mesh::unrefine_all_elements();</pre>
</div>
<p>See the file <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/src/mesh.cpp">src/mesh.cpp</a> for more details.
The following code illustrates how to visualize the mesh using the class MeshView:</p>
<div class="highlight-python"><pre>// Display the mesh.
// (0, 0) is the upper left corner position
// 350 x 350 is the window size
MeshView mview("Hello world!", new WinGeom(0, 0, 350, 350));
mview.show(&amp;mesh);</pre>
</div>
<p>You can initialize it by supplying the title of the window and its initial position and size (all of these
parameters are optional). The class MeshView provides the method show() that displays a window showing the mesh:</p>
<div align="center" class="align-center"><img alt="Image of the mesh created via the MeshView class." class="align-center" src="../../_images/meshview2.png" style="width: 400px; height: 400px;" /></div>
<p>To see the graphical output, the main.cpp file should be finished with:</p>
<div class="highlight-python"><pre>  // Wait for the view to be closed.
  View::wait();
  return 0;
}</pre>
</div>
</div>
</div>
<div class="section" id="setting-up-finite-element-space-02">
<h2>Setting Up Finite Element Space (02)<a class="headerlink" href="#setting-up-finite-element-space-02" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/02-space">02-space</a>.</p>
<p>Hermes follows the mathematical concept of FEM closely &#8211; after creating a mesh,
in the next step one needs to construct a finite element space on it.
The following predefined spaces are currently available:</p>
<ul class="simple">
<li>H1Space - the most common space of continuous, piecewise-polynomial functions belonging to <img class="math" src="../../_images/math/1de379ba3f381bb289dd641d49d819eece05a289.png" alt="H^1(\Omega) = \{ v \in L^2(\Omega); \nabla u \in [L^2(\Omega)]^2 \}"/>,</li>
<li>HcurlSpace - space of vector-valued functions discontinuous along mesh edges, with continuous tangential component on the edges <img class="math" src="../../_images/math/c2f9f27a23d70bbdcf61a17e06ed15a66e8b9fce.png" alt="H(\mbox{curl},\Omega) = \{ E \in [L^2(\Omega)]^2; \nabla \times E \in L^2(\Omega)\}"/>,</li>
<li>HdivSpace - space of vector-valued functions discontinuous along mesh edges, with continuous normal component on the edges <img class="math" src="../../_images/math/d7c321be5a58ffd9490e64d2a377a261dd9428d8.png" alt="H(\mbox{div},\Omega) = \{ v \in [L^2(\Omega)^2; \nabla \cdot v \in L^2(\Omega)\}"/>,</li>
<li>L2Space - space of functions discontinuous along mesh edges, belonging to the space <img class="math" src="../../_images/math/1d3d05785ce4f5d32dfd1a93e9960af3d9d7e768.png" alt="L^2(\Omega)"/>.</li>
</ul>
<p>All these spaces allow for higher-order elements, meshes with arbitrary-level hanging nodes,
and automatic <em>hp</em>-adaptivity.
If you are not familiar with higher-order FEM, let us just say that the spaces can contain
quadratic, cubic, etc., <em>edge functions</em> that generate higher-degree
polynomials along mesh edges, and <em>bubble functions</em> that complete the higher-order
approximation in element interiors. Edge functions are associated with mesh edges,
and bubble functions with element interiors. The next figure shows a higher-order
edge function (left) and a higher-order bubble function (right).</p>
<div align="center" class="align-center"><img alt="Fourth-order edge function  (left) and one of the fifth-order bubble functions (right)." class="align-center" src="../../_images/basisfn.jpg" style="width: 600px; height: 200px;" /></div>
<p>Higher-order basis functions can be defined in many different ways.
A particular set of polynomials is called <em>shapeset</em>. Using a good shapeset is crucial for the
performance of the <em>hp</em>-FEM. No shapeset can be optimal for all possible operators.
Therefore, Hermes offers several shapesets from which
you need to choose one when creating a FE space. The ones which perform best
in most computations (according to our experience) are simply called
H1Shapeset, HcurlShapeset, HdivShapeset and L2Shapeset.
Others can be found in the directory <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/src/shapeset">src/shapeset/</a>.</p>
<p>We are now ready for an example. The following is (up to some omitted comments) the complete
<a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/tutorial/02-space/main.cpp">main.cpp</a> file
of the example 02-space:</p>
<div class="highlight-python"><pre>#include "hermes2d.h"
int P_INIT = 3;
int main(int argc, char* argv[])
{
  // Load the mesh.
  Mesh mesh;
  H2DReader mloader;
  mloader.load("domain.mesh", &amp;mesh);

  // Create an H1 space with default shapeset and natural BC.
  H1Space space(&amp;mesh, NULL, NULL, P_INIT);

  // View FE basis functions.
  BaseView bview("FE Space", new WinGeom(0, 0, 440, 350));
  bview.show(&amp;space);

  // Wait for the view to be closed.
  View::wait();
  return 0;
}</pre>
</div>
<p>An instance of H1Space is initialized with four arguments:</p>
<ul class="simple">
<li>Pointer to a mesh,</li>
<li>function providing boundary condition types for all boundary markers
(NULL means natural boundary conditions on the entire boundary),</li>
<li>function providing values of essential (i.e., Dirichlet) boundary conditions for all
essential boundary markers (NULL here since all BC are natural),</li>
<li>uniform initial polynomial degree of all mesh elements.</li>
</ul>
<p>Polynomial degrees of elements can also be set individually by calling
the method Space::set_element_order() or for all elements at once using
Space::set_uniform_order(). Note that element degrees
are stored in Space, not in Mesh. The reason is that in Hermes one can
have multiple spaces with different element degrees and even types
over the same mesh. In Hermes, Mesh only stores geometrical information.
A space created in this way is ready for use.</p>
<p>As a debugging/learning feature, Hermes can visualize the basis of each Space.
Similarly to MeshView, one can create a BaseView object and use it
to display the entire basis (VectorBaseView has to be used for vector-valued
approximations in spaces Hcurl and Hdiv - this will be discussed later).
One can cycle through all basis functions in the window using the arrow keys.
If you press the left mouse button at the beginning, you will see the Dirichlet
lift (a function that represents Dirichlet boundary conditions).</p>
<p>This is how the last figure above was obtained (press the &#8216;3&#8217; key for 3D mode).
We suggest that you spend some time experimenting with element refinements and
hanging nodes to see how basis functions on irregular meshes look like.</p>
</div>
<div class="section" id="solving-poisson-equation-03">
<h2>Solving Poisson Equation (03)<a class="headerlink" href="#solving-poisson-equation-03" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/03-poisson">03-poisson</a>.</p>
<p>Let us solve the Poisson equation</p>
<div class="math" id="equation-poisson1">
<p><span class="eqno">(1)</span><img src="../../_images/math/bb4e8ac65da49a7eef5d8329fc5f17749f711165.png" alt="-\Delta u = CONST_F" /></p>
</div><p>on the L-shaped domain <img class="math" src="../../_images/math/9e2b196e9b7e57d1ec99f6534c581ea9759d2170.png" alt="\Omega"/> from the previous example,
equipped with homogeneous (zero) Dirichlet boundary conditions</p>
<div class="math" id="equation-poisson2">
<p><span class="eqno">(2)</span><img src="../../_images/math/972fe38606b727dd030644aef002dea0e0842a15.png" alt="u = 0\ \ \  \mbox{on}\  \partial \Omega," /></p>
</div><p>where <img class="math" src="../../_images/math/822bb265a93e916c13d8b0596e0024227464ea3b.png" alt="CONST_F"/> is a real number. The weak formulation
is derived in the standard way, first by multiplying equation <a href="#equation-poisson1">(1)</a> with a test
function <img class="math" src="../../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/>, then integrating over the domain <img class="math" src="../../_images/math/9e2b196e9b7e57d1ec99f6534c581ea9759d2170.png" alt="\Omega"/>, and then applying the Green&#8217;s
theorem (integration by parts) to the second derivatives.
Because of the homogeneous Dirichlet condition <a href="#equation-poisson2">(2)</a>,
the proper space for the solution is <img class="math" src="../../_images/math/10c6cedee32f0b8a8ab5df93a5c0d56b5b389a9e.png" alt="V = H^1_0(\Omega)"/>. The weak formulation reads:
Find <img class="math" src="../../_images/math/37074bfdd7c42f2f67130f70edbbf70cecd9c15d.png" alt="u \in V"/> such that</p>
<div class="math" id="equation-poissonweak">
<p><span class="eqno">(3)</span><img src="../../_images/math/63fd89bdbbb1b8adbf864b64ed98876764a62ea0.png" alt="\int_\Omega \nabla u \cdot \nabla v \;\mbox{d\bfx} = CONST_F \int_\Omega v \;\mbox{d\bfx} \ \ \ \mbox{for all}\ v \in V." /></p>
</div><p>Equation <a href="#equation-poissonweak">(3)</a> has the standard form <img class="math" src="../../_images/math/0077d69d946acf2d134d2dead17b5492d4dc3223.png" alt="a(u,v) = l(v)"/>. The bilinear form <img class="math" src="../../_images/math/582756f2f2ea8727397157cfb8638bd8f53138e8.png" alt="a(u,v)"/>
and the linear form <img class="math" src="../../_images/math/24c0b2ffc973b0eb2aa7e73d4f568925c0553ba8.png" alt="l(v)"/> are defined as follows:</p>
<div class="highlight-python"><pre>// Return the value \int \nabla u \cdot \nabla v dx.
template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  Scalar result = 0;
  for (int i = 0; i &lt; n; i++) result += wt[i] * (u-&gt;dx[i] * v-&gt;dx[i] + u-&gt;dy[i] * v-&gt;dy[i]);
  return result;
}

// Return the value CONST_F \int v dx.
template&lt;typename Real, typename Scalar&gt;
Scalar linear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  Scalar result = 0;
  for (int i = 0; i &lt; n; i++) result += wt[i] * (v-&gt;val[i]);
  return CONST_F * result;
}</pre>
</div>
<p>These functions are called for each element during the assembly and they must return the
values of the bilinear and linear forms for the given arguments. The arguments have the
following meaning:</p>
<blockquote>
<ul class="simple">
<li><em>n</em> ... the number of integration points (provided by Hermes automatically),</li>
<li><em>wt</em> ... array of integration weights for all integration points,</li>
<li><em>u_ext</em> ... solution values (for nonlinear problems only, to be discussed later),</li>
<li><em>u</em> ... basis function,</li>
<li><em>v</em> ... test function,</li>
<li><em>e</em> ... geometrical information such as physical positions of integration points, tangent and normal vectors to element edges, etc. (to be discussed later),</li>
<li><em>ext</em> ... external data to be passed into the weak forms (to be discussed later).</li>
</ul>
</blockquote>
<p>The reader does not have to worry about the templates for now - they are used by Hermes to
automatically determine the number of integration points for each <em>u</em> and <em>v</em> pair (to be discussed
later). The code also reveals how the function values and partial derivatives of the basis and
test functions are accessed.</p>
<p>In many cases, such as in this one, one can replace the above code with simple predefined functions
that can be found in the file <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/src/integrals_h1.h">integrals_h1.h</a>:</p>
<div class="highlight-python"><pre>// Return the value \int \nabla u . \nabla v dx.
template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return int_grad_u_grad_v&lt;Real, Scalar&gt;(n, wt, u, v);
}

// Return the value \int v dx.
template&lt;typename Real, typename Scalar&gt;
Scalar linear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return CONST_F * int_v&lt;Real, Scalar&gt;(n, wt, v);
}</pre>
</div>
<p>Predefined functions like this also exist for the Hcurl, Hdiv and L2 spaces. The weak forms are registered as follows:</p>
<div class="highlight-python"><pre>// Initialize the weak formulation.
WeakForm wf();
wf.add_matrix_form(callback(bilinear_form));
wf.add_vector_form(callback(linear_form));</pre>
</div>
<p>The reader does not have to worry about the macro <em>callback()</em> for the moment, this is
related to automatic determination of integration order (to be discussed later).
For more complicated PDE and PDE systems one can add multiple matrix and vector forms.
With the space and weak formulation in hand, the problem can be solved simply via:</p>
<div class="highlight-python"><pre>// Solve the linear problem.
Solution sln;
solve_linear(&amp;space, &amp;wf, SOLVER_UMFPACK, &amp;sln);</pre>
</div>
<p>The parameter SOLVER_UMFPACK indicates that we are using the direct sparse matrix solver UMFpack. Other options include SOLVER_PETSC, SOLVER_MUMPS, SOLVER_PARDISO, a variety of SciPy matrix solvers and others (to be discussed later).</p>
<p>The solution can be visualized via the ScalarView class:</p>
<div class="highlight-python"><pre>// Visualize the solution.
ScalarView view("Solution", new WinGeom(0, 0, 440, 350));
view.show(&amp;sln);</pre>
</div>
<p>The following figure shows the output of this example (again, press &#8216;3&#8217; for 3D view).</p>
<div align="center" class="align-center"><img alt="Solution of the Poisson equation." class="align-center" src="../../_images/poisson.png" style="width: 400px; height: 350px;" /></div>
</div>
<div class="section" id="short-and-long-versions-of-examples">
<h2>Short and Long Versions of Examples<a class="headerlink" href="#short-and-long-versions-of-examples" title="Permalink to this headline">¶</a></h2>
<p>Some tutorial examples come in two versions: A short one that is intended for effortless basic use, and a long one that is more explicit and thus more convenient for development. The first example with a long version is 03-poisson.</p>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/03-poisson-long">03-poisson-long</a>.</p>
<p>The long version does not employ the function solve_linear(). Instead, after initializing the weak formulation, one initializes the LinearProblem class:</p>
<div class="highlight-python"><pre>// Initialize the linear problem.
LinearProblem lp(&amp;wf, &amp;space);</pre>
</div>
<p>This class is a descendant of a more general DiscreteProblem class that handles nonlinear problems. Next we initialize the matrix solver and the corresponding matrix and vector structures:</p>
<div class="highlight-python"><pre>// Select matrix solver.
Matrix* mat; Vector* rhs; CommonSolver* solver;
init_matrix_solver(SOLVER_UMFPACK, ndof, mat, rhs, solver);</pre>
</div>
<p>Again, other matrix solvers besides SOLVER_UMFPACK can be used. The variable <em>ndof</em> stands for the number of degrees of greedom (unknowns in the discrete problem) that can be calculated after initializing a Space:</p>
<div class="highlight-python"><pre>int ndof = get_num_dofs(&amp;space);</pre>
</div>
<p>Assembling is done into the user-provided data structures:</p>
<div class="highlight-python"><pre>// Assemble stiffness matrix and rhs.
lp.assemble(mat, rhs);</pre>
</div>
<p>After this, the matrix problem is solved:</p>
<div class="highlight-python"><pre>// Solve the matrix problem.
if (!solver-&gt;solve(mat, rhs)) error ("Matrix solver failed.\n");</pre>
</div>
<p>And finally, the solution vector is translated into a Solution:</p>
<div class="highlight-python"><pre>// Convert coefficient vector into a Solution.
Solution* sln = new Solution(&amp;space, rhs);</pre>
</div>
<p>For this, one can also use the method Solution::set_coeff_vector():</p>
<div class="highlight-python"><pre>// Convert coefficient vector into a Solution.
Solution sln;
sln.set_coeff_vector(&amp;space, rhs);</pre>
</div>
<p>Visualization and the rest of the main() function are the same as in the short version.</p>
</div>
<div class="section" id="boundary-conditions-04-05-06">
<h2>Boundary Conditions (04, 05, 06)<a class="headerlink" href="#boundary-conditions-04-05-06" title="Permalink to this headline">¶</a></h2>
<p>Hermes recognizes two basic types of boundary conditions: <em>essential</em> and <em>natural</em>.
Essential boundary conditions (prescribed values on the boundary) influence the finite element
space while natural conditions do not - they are incorporated into boundary integrals in the weak formulation.
In the context of elliptic problems, Dirichlet conditions are essential and Neumann/Newton
conditions are natural.</p>
<p>Examples 04, 05 and 06 also come in long versions but we will not discuss them explicitly since they are analogous to the long version of example 03.</p>
<div class="section" id="dirichlet-bc">
<h3>Dirichlet BC<a class="headerlink" href="#dirichlet-bc" title="Permalink to this headline">¶</a></h3>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/04-bc-dirichlet">04-bc-dirichlet</a>. Long version: <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/04-bc-dirichlet-long">04-bc-dirichlet-long</a>.</p>
<p>Since essential boundary conditions eliminate degrees of freedom (DOF) from the FE space,
they need to be incorporated while the space is set up.
The user has to provide the following two callback functions:</p>
<div class="highlight-python"><pre>BCType bc_types(int marker);
scalar essential_bc_values(int ess_bdy_marker, double x, double y);</pre>
</div>
<p>The first one takes as argument a boundary marker number, and it determines the type of BC
for the corresponding portion of the domain boundary, by returning one of the predefined constants
BC_ESSENTIAL, BC_NATURAL. The second callback needs to return the boundary value for a given marker
and position on the boundary (only needed for essential boundary condition markers - for natural
boundary conditions this value is ignored). The space initialization then consists of the following
line:</p>
<div class="highlight-python"><pre>H1Space space(&amp;mesh, bc_types, essential_bc_values, P_INIT);</pre>
</div>
<p>Here P_INIT is the initial polynomial degree of all elements in the mesh as before.
Suppose that we would like to modify the boundary conditions for the previous Poisson
model problem as follows:</p>
<div class="math">
<p><img src="../../_images/math/78b4ab961c94634e21304dc6b535e8844ccc95e7.png" alt="u(x,y) = -\frac{CONST_F}{4}(x^2 + y^2)\,\ \mbox{on}\,\ \partial \Omega." /></p>
</div><p>This is done by defining</p>
<div class="highlight-python"><pre>BCType bc_types(int marker)
{
  return BC_ESSENTIAL;
}</pre>
</div>
<p>and setting the essential BC values callback to return the value of the Dirichlet BC:</p>
<div class="highlight-python"><pre>scalar essential_bc_values(int ess_bdy_marker, double x, double y)
{
  return (-CONST_F/4)*(x*x + y*y);
}</pre>
</div>
<p>It is easy to see that the solution to this problem is the function</p>
<div class="math">
<p><img src="../../_images/math/37dda06f75ecab90f2eb2e4867dd90c8bb46747b.png" alt="u(x,y) = -\frac{CONST_F}{4}(x^2 + y^2)." /></p>
</div><p>For the value <img class="math" src="../../_images/math/ffa365fa9500e26619f7b2b9256774e1d9c9a892.png" alt="CONST_F = -4"/>, the output is shown below:</p>
<div align="center" class="align-center"><img alt="Solution of the Dirichlet problem." class="align-center" src="../../_images/dirichlet.png" style="width: 400px; height: 350px;" /></div>
</div>
<div class="section" id="neumann-bc">
<h3>Neumann BC<a class="headerlink" href="#neumann-bc" title="Permalink to this headline">¶</a></h3>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/05-bc-neumann">05-bc-neumann</a>. Long version: <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/05-bc-neumann-long">05-bc-neumann-long</a>.</p>
<p>Next, let us consider Neumann boundary conditions. The new model problem
will have the form</p>
<div class="math">
<p><img src="../../_images/math/fbd8db5499d7137a9c226047d4be3b0227de8eae.png" alt="\begin{eqnarray*}   -\Delta u = CONST_F,\ \ \ \ \ &amp;&amp;u = 0\,\ \mbox{on}\,\ \Gamma_4,\\                            &amp;&amp;\dd{u}{n} = C_1\,\ \mbox{on}\,\ \Gamma_1,\\                            &amp;&amp;\dd{u}{n} = C_2\,\ \mbox{on}\,\ \Gamma_2,\\                            &amp;&amp;\dd{u}{n} = C_3\,\ \mbox{on}\,\ \Gamma_3. \end{eqnarray*}" /></p>
</div><p>where <img class="math" src="../../_images/math/7badba645a303d5353ca9aa2cd725edef600d1d6.png" alt="\Gamma_1 \dots \Gamma_4"/> correspond to the edges marked <img class="math" src="../../_images/math/3ffc2f3aec7a9bcac18e532620ed760643f1e706.png" alt="1 \dots 4"/>. Now, the weak formulation contains some surface integrals:</p>
<div class="math">
<p><img src="../../_images/math/ae256e5ee343ff714e9a8147d8aa583a687e839a.png" alt="\int_\Omega \nabla u \cdot \nabla v \;\mbox{d\bfx} =   CONST_F\int_\Omega v \;\mbox{d\bfx}   + C_1\int_{\Gamma_1} \!v \;\mbox{d}l   + C_2\int_{\Gamma_2} \!v \;\mbox{d}l   + C_3\int_{\Gamma_3} \!v \;\mbox{d}l" /></p>
</div><p>In Hermes, all forms in the standard weak formulation <img class="math" src="../../_images/math/0077d69d946acf2d134d2dead17b5492d4dc3223.png" alt="a(u,v) = l(v)"/>
are in fact defined as a sum of contributions from volume integrals and from
surface integrals. In the case of the linear form <img class="math" src="../../_images/math/24c0b2ffc973b0eb2aa7e73d4f568925c0553ba8.png" alt="l(v)"/>, this means</p>
<div class="math">
<p><img src="../../_images/math/2973dc6ce14143403850cd5a53bbad5a32e8ebc0.png" alt="l(v) = \sum_m l_m^{\,\rm vol}(v) + \sum_n l_n^{\,\rm surf}(v)." /></p>
</div><p>We have already seen volumetric linear forms in example
<a class="reference external" href="http://hpfem.org/hermes2d/doc/src/tutorial-1.html#solving-poisson-equation-03">03-poisson</a>.
Surface linear forms are implemented similarly. Our new right-hand side is
represented by two functions with the following prototypes:</p>
<div class="highlight-python"><pre>template&lt;typename Real, typename Scalar&gt;
Scalar linear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)

template&lt;typename Real, typename Scalar&gt;
Scalar linear_form_surf(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext);</pre>
</div>
<p>and registered as follows:</p>
<div class="highlight-python"><pre>// Initialize the weak formulation
WeakForm wf();
wf.add_matrix_form(callback(bilinear_form));
wf.add_vector_form(callback(linear_form));
wf.add_vector_form_surf(callback(linear_form_surf));</pre>
</div>
<p>The surface linear form is defined as:</p>
<div class="highlight-python"><pre>template&lt;typename Real, typename Scalar&gt;
Scalar linear_form_surf(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return CONST_GAMMA[e-&gt;marker - 1] * int_v&lt;Real, Scalar&gt;(n, wt, v);
}</pre>
</div>
<p>Here, we have used the predefined surface integral int_v (see the
file <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/src/integrals_h1.h">src/integrals_h1.h</a>).
If the boundary conditions were more complicated, we could also
have used int_F_v, where F stands for an arbitrary user-supplied
function returning the value <img class="math" src="../../_images/math/303a61f26cb4c0a4cbb775c2c5729c97f8381654.png" alt="\partial u/\partial n"/>.</p>
<p>Note that in this example, the mesh is a-priori refined towards the re-entrant corner
to capture the singular gradient:</p>
<div class="highlight-python"><pre>mesh.refine_towards_vertex(3, CORNER_REF_LEVEL);  // '3' is the vertex index from the mesh file.</pre>
</div>
<p>The gradient magnitude can be visualized via a MagFilter:</p>
<div class="highlight-python"><pre>// Compute and show gradient magnitude
// (note that the infinite gradient at the re-entrant
// corner will be truncated for visualization purposes)
ScalarView gradview("Gradient", grad_win_geom);
MagFilter grad(Tuple&lt;MeshFunction&gt;(&amp;sln, &amp;sln), Tuple&lt;int&gt;(H2D_FN_DX, H2D_FN_DY));
gradview.show(&amp;grad);</pre>
</div>
<p>Here we first meet Tuple - a construction designed to avoid variable argument
lists. The first Tuple is used to pass a pair of pointers to the same MeshFunction,
and the next Tuple says that the vector components for the magnitude calculation
are the x- and y- partial derivatives. The class Solution that represents a piecewise-polynomial
finite element function on a Mesh, is descendant of a more general class MeshFunction
that can represent constants, general functions given via an analytic formula,
finite element solutions, etc.</p>
<p>The approximate solution for the values <img class="math" src="../../_images/math/c637f5365461351d15a3664ca9f7ab16bd971e1f.png" alt="C_1 = -1/2"/>, <img class="math" src="../../_images/math/6e0a5aead379ec52659417db5968294646ec31e2.png" alt="C_2 = 1"/>, <img class="math" src="../../_images/math/f9a84498aa059fc18fb336102836d5ba29437e27.png" alt="C_3 = -1/2"/>,
along with the singularity of gradient at the re-entrant corner are
shown in the following figures:</p>
<img align="left" alt="Solution of the Neumann problem." class="align-left" src="../../_images/neumann2.png" style="width: 530px; height: 400px;" />
<img align="right" alt="Detail of gradient singularity at the re-entrant corner." class="align-right" src="../../_images/neumann3.png" style="width: 400px; height: 400px;" />
<hr style="clear: both; visibility: hidden;"></div>
<div class="section" id="newton-bc">
<h3>Newton BC<a class="headerlink" href="#newton-bc" title="Permalink to this headline">¶</a></h3>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/06-bc-newton">06-bc-newton</a>. Long version: <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/06-bc-newton-long">06-bc-newton-long</a>.</p>
<p>Another common natural boundary condition is the Newton (sometimes called Robin) condition
of the form</p>
<div class="math">
<p><img src="../../_images/math/1c0cf7be8f7eafa57d8506145feac5b7b017ab6b.png" alt="\dd{u}{n} + c_1 u = c_2, \ \ \ \ c_1 \ne 0." /></p>
</div><p>Analogously to Neumann conditions, also Newton conditions yield surface integrals. However,
this time they are both in the bilinear form and in the linear form,
The bilinear form is
a sum of volume and surface forms that can be added to the weak formulation using the methods
add_matrix_form() and add_matrix_form_surf().
The surface bilinear form must have the following prototype:</p>
<div class="highlight-python"><pre>template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form_surf(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext);</pre>
</div>
<p>Inside this function you can use predefined
forms such as int_u_v, int_F_u_v (see the
file <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/src/integrals_h1.h">src/integrals_h1.h</a>) or your custom forms.</p>
<p>The following code snippet contains the linear and bilinear forms:</p>
<div class="highlight-python"><pre>template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return int_grad_u_grad_v&lt;Real, Scalar&gt;(n, wt, u, v);
}

template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form_surf(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return H * int_u_v&lt;Real, Scalar&gt;(n, wt, u, v);
}

template&lt;typename Real, typename Scalar&gt;
Scalar linear_form_surf(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return T0 * H * int_v&lt;Real, Scalar&gt;(n, wt, v);
}</pre>
</div>
<p>Here, <img class="math" src="../../_images/math/6801c07694edb238c4a095956d8bf46ccdb38fcc.png" alt="T_0"/> is the exterior temperature, and <img class="math" src="../../_images/math/b1902d279ba37d60bdce4e0e987b7cd19d48974e.png" alt="H"/> is the heat flux.
The above forms are registered using:</p>
<div class="highlight-python"><pre>// Initialize the weak formulation.
WeakForm wf;
wf.add_matrix_form(callback(bilinear_form));
wf.add_matrix_form_surf(callback(bilinear_form_surf), NEWTON_BDY);
wf.add_vector_form_surf(callback(linear_form_surf), NEWTON_BDY);</pre>
</div>
<p>Here NEWTON_BDY is the boundary marker for the Newton boundary. The following figures
show the solution and singularity of gradient at the re-entrant corner:</p>
<img align="left" alt="Solution of the Newton problem." class="align-left" src="../../_images/newton1.png" style="width: 530px; height: 400px;" />
<img align="right" alt="Detail of gradient singularity at the re-entrant corner." class="align-right" src="../../_images/newton2.png" style="width: 400px; height: 400px;" />
<hr style="clear: both; visibility: hidden;"></div>
</div>
<div class="section" id="determination-of-quadrature-orders-in-weak-forms">
<h2>Determination of Quadrature Orders in Weak Forms<a class="headerlink" href="#determination-of-quadrature-orders-in-weak-forms" title="Permalink to this headline">¶</a></h2>
<p>You may wonder why templates are used in the definition of weak forms. As a matter of fact,
they do not have to be, as we will see in a moment. However, if the weak form only contains
algebraic operations (without if-then statements and such), templates help to determine
numerical integration orders automatically. In higher-order FEM, basis and test functions may
have very different polynomial degrees, ranging from one and some maximum polynomial
degree (currently 10 in Hermes). The basis and test functions can be combined inside the
weak forms in many different ways. As a result, the minimum quadrature order which is needed
to evaluate a weak form accurately may vary between zero (product of gradients of
two linear functions) to infinity (whenever a nonpolynomial expression is present).
Numerical quadrature is one of the trickiest issues in higher-order FEM.</p>
<p>A brute-force solution to this problem would be to integrate everything using
a maximum order, but this would lead to tremendous computing times. Therefore Hermes offers
two options: the polynomial degree of the integrated expressions can be detected
automatically (via templates), or the user can define for each weak form the
quadrature order explicitly. If the weak form only contains polynomial expressions,
the former approach works very well. If the form is more complicated, it is recommended
to handle the integration orders explicitly.</p>
<div class="section" id="automatic-determination-of-quadrature-order">
<h3>Automatic determination of quadrature order<a class="headerlink" href="#automatic-determination-of-quadrature-order" title="Permalink to this headline">¶</a></h3>
<p>In example 03-poisson, the bilinear and linear forms were defined using templates,</p>
<div class="highlight-python"><pre>// return the value \int \nabla u . \nabla v dx
template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return int_grad_u_grad_v&lt;Real, Scalar&gt;(n, wt, u, v);
}

// return the value \int v dx
template&lt;typename Real, typename Scalar&gt;
Scalar linear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return CONST_F * int_v&lt;Real, Scalar&gt;(n, wt, v);
}</pre>
</div>
<p>and registered using the callback() macro,</p>
<div class="highlight-python"><pre>// initialize the weak formulation
WeakForm wf();
wf.add_matrix_form(callback(bilinear_form));
wf.add_vector_form(callback(linear_form));</pre>
</div>
<p>The callback() macro, defined in <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/src/forms.h">src/forms.h</a> by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#define callback(a)     a&lt;double, scalar&gt;, a&lt;Ord, Ord&gt;</span>
</pre></div>
</div>
<p>expands the above add_matrix_form() and add_vector_form() functions into</p>
<div class="highlight-python"><pre>// initialize the weak formulation
WeakForm wf();
wf.add_matrix_form(bilinear_form&lt;double, scalar&gt;, bilinear_form&lt;Ord, Ord&gt;);
wf.add_vector_form(linear_form&lt;double, scalar&gt;, linear_form&lt;Ord, Ord&gt;);</pre>
</div>
<p>For those who are not familiar with templates, they make it possible to
call the same function with different parameter types. In particular,
using bilinear_form&lt;double, scalar&gt; and bilinear_form&lt;Ord, Ord&gt; for
the bilinear form defined above gives</p>
<div class="highlight-python"><pre>scalar bilinear_form(int n, double *wt, Func&lt;scalar&gt; *u_ext[], Func&lt;double&gt; *u, Func&lt;double&gt; *v, Geom&lt;double&gt; *e, ExtData&lt;scalar&gt; *ext)
{
  return int_grad_u_grad_v&lt;double, scalar&gt;(n, wt, u, v);
}

Ord bilinear_form(int n, double *wt, Func&lt;Ord&gt; *u_ext[], Func&lt;Ord&gt; *u, Func&lt;Ord&gt; *v, Geom&lt;Ord&gt; *e, ExtData&lt;Ord&gt; *ext)
{
  return int_grad_u_grad_v&lt;Ord, Ord&gt;(n, wt, u, v);
}</pre>
</div>
<p>The &lt;double, scalar&gt; copy is used to obtain the result of the numerical integration,
the &lt;Ord, Ord&gt; copy for automatic evaluation of the quadrature order.
The parser (see <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/src/forms.h">src/forms.h</a>)
works well for algebraic expressions. If the weak form bilinear_form() is complicated,
one can create and register a simpler weak form bilinear_form_order() for the parser,
that provides an arbitrary expression with the same polynomial degree as
the integrand in bilinear_form(). Then the two functions would be registered as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">wf</span><span class="o">.</span><span class="n">add_matrix_form</span><span class="p">(</span><span class="n">bilinear_form</span><span class="p">,</span> <span class="n">bilinear_form_order</span><span class="p">);</span>
</pre></div>
</div>
<p>Of course the same holds for linear forms.
If the bilinear form contains things like the if-then statement, it cannot
be parsed. Whenever the weak form contains non-polynomial expressions or
is otherwise very complicated, it is recommended to handle the quadrature
orders manually.</p>
</div>
<div class="section" id="manual-determination-of-quadrature-order">
<h3>Manual determination of quadrature order<a class="headerlink" href="#manual-determination-of-quadrature-order" title="Permalink to this headline">¶</a></h3>
<p>The polynomial degree of basis and test functions inside a bilinear or linear form
can be handled manually as follows</p>
<div class="highlight-python"><pre>Ord bilinear_form_order(int n, double *wt, Func&lt;Ord&gt; *u_ext[], Func&lt;Ord&gt; *u,
                      Func&lt;Ord&gt; *v, Geom&lt;Ord&gt; *e, ExtData&lt;Ord&gt; *ext)
{
  int uo = u-&gt;val[0].get_order();
  int vo = v-&gt;val[0].get_order();
  return Ord(uo + vo);            // this would correspond to integral of u times v
}</pre>
</div>
<p>It is also possible to return a constant order (for example 5) by using</p>
<div class="highlight-python"><pre>Ord bilinear_form_ord(int n, double *wt, Func&lt;Ord&gt; *u_ext[], Func&lt;Ord&gt; *u,
                  Func&lt;Ord&gt; *v, Geom&lt;Ord&gt; *e, ExtData&lt;Ord&gt; *ext)
{
  return Ord(5);
}</pre>
</div>
<p>Currently, one cannot make the integration order dependent on spatial coordinates and such. However,
one can assign different weak forms to elements with different material markers. This is
described in examples <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/examples/iron-water">iron-water</a>,
<a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/examples/saphir/main.cpp">saphir</a> and others.</p>
<p>The following example handles quadrature orders manually.</p>
</div>
</div>
<div class="section" id="general-2nd-order-linear-equation-07">
<h2>General 2nd-Order Linear Equation (07)<a class="headerlink" href="#general-2nd-order-linear-equation-07" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/07-general">07-general</a>. Long version: <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/07-general-long">07-general-long</a>.</p>
<p>This example deals with a linear second-order equation of the form</p>
<div class="math">
<p><img src="../../_images/math/4ffccfac1cf2eb3751ce64dde95c1502fb953491.png" alt="-\frac{\partial}{\partial x}\left(a_{11}(x,y)\frac{\partial u}{\partial x}\right) - \frac{\partial}{\partial x}\left(a_{12}(x,y)\frac{\partial u}{\partial y}\right) - \frac{\partial}{\partial y}\left(a_{21}(x,y)\frac{\partial u}{\partial x}\right) - \frac{\partial}{\partial y}\left(a_{22}(x,y)\frac{\partial u}{\partial y}\right) + a_1(x,y)\frac{\partial u}{\partial x} + a_{21}(x,y)\frac{\partial u}{\partial y} + a_0(x,y)u = rhs(x,y)," /></p>
</div><p>equipped with Dirichlet and/or Neumann boundary conditions. Its goal is to show how to
use space-dependent coefficients and how to define quadrature orders explicitly.</p>
<p>First we define the (generally) non-constant equation coefficients:</p>
<div class="highlight-python"><pre>double a_11(double x, double y) {
  if (y &gt; 0) return 1 + x*x + y*y;
  else return 1;
}</pre>
</div>
<p>and so on. Then we define boundary conditions as usual. The weak formulation contains
both volumetric and surface integrals.</p>
<p>The Ord class in Hermes (see the file <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/src/forms.h">src/forms.h</a>) provides
an automatic parser of weak forms that is able to determine the integration orders for
algebraic expressions. So, in order to define an integration order explicitly, one can
provide on top the weak form another function that defines a simple algebraic expression
that leads the parser to the desired polynomial degree. The values defined in this
additional function are not used for computation.</p>
<div class="highlight-python"><pre>// (Volumetric) bilinear form
template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  Scalar result = 0;
  for (int i=0; i &lt; n; i++) {
    double x = e-&gt;x[i];
    double y = e-&gt;y[i];
    result += (a_11(x, y)*u-&gt;dx[i]*v-&gt;dx[i] +
               a_12(x, y)*u-&gt;dy[i]*v-&gt;dx[i] +
               a_21(x, y)*u-&gt;dx[i]*v-&gt;dy[i] +
               a_22(x, y)*u-&gt;dy[i]*v-&gt;dy[i] +
               a_1(x, y)*u-&gt;dx[i]*v-&gt;val[i] +
               a_2(x, y)*u-&gt;dy[i]*v-&gt;val[i] +
               a_0(x, y)*u-&gt;val[i]*v-&gt;val[i]) * wt[i];
  }
  return result;
}

// Integration order for the bilinear form
Ord bilinear_form_ord(int n, double *wt, Func&lt;Ord&gt; *u_ext[], Func&lt;Ord&gt; *u,
                  Func&lt;Ord&gt; *v, Geom&lt;Ord&gt; *e, ExtData&lt;Ord&gt; *ext)
{
  return u-&gt;val[0] * v-&gt;val[0] * e-&gt;x[0] * e-&gt;x[0]; // returning the sum of the degrees of the basis
                                                    // and test function plus two
}

// Surface linear form (natural boundary conditions)
template&lt;typename Real, typename Scalar&gt;
Scalar linear_form_surf(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return int_F_v&lt;Real, Scalar&gt;(n, wt, g_N, v, e);
}

// Integration order for surface linear form
Ord linear_form_surf_ord(int n, double *wt, Func&lt;Ord&gt; *u_ext[], Func&lt;Ord&gt; *v, Geom&lt;Ord&gt; *e, ExtData&lt;Ord&gt; *ext)
{
  return v-&gt;val[0] * e-&gt;x[0] * e-&gt;x[0];  // returning the polynomial degree of the test function plus two
}

// Volumetric linear form (right-hand side)
template&lt;typename Real, typename Scalar&gt;
Scalar linear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return int_F_v&lt;Real, Scalar&gt;(n, wt, rhs, v, e);
}

// Integration order for the volumetric linear form
Ord linear_form_ord(int n, double *wt, Func&lt;Ord&gt; *u_ext[], Func&lt;Ord&gt; *v, Geom&lt;Ord&gt; *e, ExtData&lt;Ord&gt; *ext)
{
  return v-&gt;val[0] * e-&gt;x[0] * e-&gt;x[0];  // returning the polynomial degree of the test function plus two
}</pre>
</div>
<p>Note the sign of the surface linear form - when using the LinearProblem class, all linear forms have to be on the right-hand side and all bilinear forms on the left.</p>
<p>The output of this example is shown below:</p>
<div align="center" class="align-center"><img alt="Output of example 07-general." class="align-center" src="../../_images/general.png" style="width: 500px; height: 400px;" /></div>
</div>
<div class="section" id="systems-of-equations-08">
<h2>Systems of Equations (08)<a class="headerlink" href="#systems-of-equations-08" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/08-system">08-system</a>. Long version <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/08-system-long">08-system-long</a>.</p>
<p>So far we have just solved single linear PDE problems with a weak formulation
of the form <img class="math" src="../../_images/math/0077d69d946acf2d134d2dead17b5492d4dc3223.png" alt="a(u,v) = l(v)"/>, where <img class="math" src="../../_images/math/7278fc3f9ba8967a3a367ff2e12c6db9387d1094.png" alt="u, v"/> were continuous approximations in the
<img class="math" src="../../_images/math/ee500eed1910756eedebc53f0079d3aaf7a5753f.png" alt="H^1"/> space. One can also solve equations whose solutions lie in the spaces
<img class="math" src="../../_images/math/d015ab117f4c71f12005755e60a077278cd306ec.png" alt="Hcurl"/>, <img class="math" src="../../_images/math/668dcbe361338eb7374da6eff016bb0ffacf9498.png" alt="Hdiv"/> or <img class="math" src="../../_images/math/07c3de5211dc08b13546363f8b139700a16dd963.png" alt="L^2"/>, and one can combine these spaces for PDE systems.</p>
<p>Here we show how to handle systems of linear PDE whose weak formulation is written as</p>
<div class="math" id="equation-weaksystem">
<p><span class="eqno">(4)</span><img src="../../_images/math/81a047b0a13a30f53d0073d4eaf52da86a69da46.png" alt="a_{11}(u_1,v_1)\,+ a_{12}(u_2,v_1)\,+ \cdots\,+ a_{1n}(u_n,v_1) = l_1(v_1),

  a_{21}(u_1,v_2)\,+ a_{22}(u_2,v_2)\,+ \cdots\,+ a_{2n}(u_n,v_2) = l_2(v_2),

                                                      \vdots

  a_{n1}(u_1,v_n) + a_{n2}(u_2,v_n) + \cdots + a_{nn}(u_n,v_n) = l_n(v_n)." /></p>
</div><p>The solution <img class="math" src="../../_images/math/98b98cf6891122bd67e4d972066955e359c4a64a.png" alt="u = (u_1, u_2, \dots, u_n)"/> and test functions <img class="math" src="../../_images/math/8221472ed78f6cdfc4bda58912c32810ea1b3fcb.png" alt="v =
(v_1, v_2, \dots, v_n)"/> belong to the space <img class="math" src="../../_images/math/e47486f66b7077f3de75473d672a08e6840839bc.png" alt="W = V_1 \times V_2 \times \dots
\times V_n"/>, where each <img class="math" src="../../_images/math/eed415fecae2ca4477fa58c7d570aa39facec00f.png" alt="V_i"/> is one of the available function spaces <img class="math" src="../../_images/math/ee500eed1910756eedebc53f0079d3aaf7a5753f.png" alt="H^1"/>,
<img class="math" src="../../_images/math/928b542ee3390cf556eb46fa091283f67930bcd8.png" alt="H(curl)"/>, <img class="math" src="../../_images/math/ea0a661e606b1a0c0cde08855bf71bfcdc633d48.png" alt="H(div)"/> or <img class="math" src="../../_images/math/07c3de5211dc08b13546363f8b139700a16dd963.png" alt="L^2"/>. The resulting discrete matrix problem will have
an <img class="math" src="../../_images/math/c3d38f82f48ef9e81c04d49354293305b0067afc.png" alt="n \times n"/> block structure.</p>
<p>Let us illustrate this by solving a simple problem of linear elasticity. Consider a
two-dimensional elastic body shown in the following figure (the bottom edge is
axis of planar symmetry):</p>
<div align="center" class="align-center"><img alt="Geometry and boundary conditions." class="align-center" src="../../_images/elastsample.png" style="width: 500px; height: 300px;" /></div>
<p>In the plane-strain model of linear elasticity the goal is to determine the
deformation of the body subject to the forces <img class="math" src="../../_images/math/bb2c93730dbb48558bb3c4738c956c4e8f816437.png" alt="f"/>. The deformation is sought
as a vector function <img class="math" src="../../_images/math/6b145fd38b0eadbe1d73dd035348dd3811e9d9f5.png" alt="u(x) = (u_1, u_2)^T"/>, describing the displacement of each point
<img class="math" src="../../_images/math/1911af95d8b411fa9c84659bd52a35460d9b2eeb.png" alt="x \in \Omega"/> after the load <img class="math" src="../../_images/math/1d2294b844e606235c9f1b1fbe5cf7024a514ad1.png" alt="f = (f_1, f_2)^T"/> is applied.</p>
<p>The boundary conditions are</p>
<div class="math">
<p><img src="../../_images/math/d07e0865824532068ab8886296d61be25e08f35e.png" alt="\begin{eqnarray*}
\frac{\partial u_1}{\partial n} &amp;=&amp; f_1 \ \text{on $\Gamma_3$,} \\
\frac{\partial u_1}{\partial n} &amp;=&amp; 0 \ \text{on $\Gamma_2$, $\Gamma_4$, $\Gamma_5$,} \\
\frac{\partial u_2}{\partial n} &amp;=&amp; f_2 \ \text{on $\Gamma_3$,} \\
\frac{\partial u_2}{\partial n} &amp;=&amp; 0 \ \text{on $\Gamma_2$, $\Gamma_4$, $\Gamma_5$,} \\
u_1 &amp;=&amp; u_2 = 0 \ \mbox{on} \ \Gamma_1.
\end{eqnarray*}" /></p>
</div><p>Applying the standard procedure to the elastostatic equilibrium equations, we arrive at the following weak formulation:</p>
<div class="math">
<p><img src="../../_images/math/06ac202d874b7054806e7a80db30956b1e76e6d9.png" alt="\begin{eqnarray*}   \int_\Omega     (2\mu\!+\!\lambda)\dd{u_1}{x_1}\dd{v_1}{x_1} + \mu\dd{u_1}{x_2}\dd{v_1}{x_2} +     \mu\dd{u_2}{x_1}\dd{v_1}{x_2} + \lambda\dd{u_2}{x_2}\dd{v_1}{x_1}     \,\mbox{d}\bfx \!\!&amp;=&amp;\!\!\!     \int_{\Gamma_3} \!\!f_1 v_1 \,\mbox{d}S, \\ \smallskip   \int_\Omega     \mu\dd{u_1}{x_2}\dd{v_2}{x_1} + \lambda\dd{u_1}{x_1}\dd{v_2}{x_2} +     (2\mu\!+\!\lambda)\dd{u_2}{x_2}\dd{v_2}{x_2} + \mu\dd{u_2}{x_1}\dd{v_2}{x_1}     \,\mbox{d}\bfx \!\!&amp;=&amp;\!\!\!     \int_{\Gamma_3} \!\!f_2 v_2 \,\mbox{d}S. \end{eqnarray*}" /></p>
</div><p>We see that the weak formulation can indeed be written in the form <a href="#equation-weaksystem">(4)</a>:</p>
<div class="math">
<p><img src="../../_images/math/70391bbac1bd14323064ed16890f7a5fbaebd5d9.png" alt="\begin{eqnarray*}
  a_{11}(u_1, v_1) \!&amp;=&amp;\! \int_\Omega (2\mu+\lambda)\dd{u_1}{x_1}\dd{v_1}{x_1} + \mu\dd{u_1}{x_2}\dd{v_1}{x_2} \,\mbox{d}\bfx,  \\
  a_{12}(u_2, v_1) \!&amp;=&amp;\! \int_\Omega \mu\dd{u_2}{x_1}\dd{v_1}{x_2} + \lambda\dd{u_2}{x_2}\dd{v_1}{x_1} \,\mbox{d}\bfx,\\
  a_{21}(u_1, v_2) \!&amp;=&amp;\! \int_\Omega \mu\dd{u_1}{x_2}\dd{v_2}{x_1} + \lambda\dd{u_1}{x_1}\dd{v_2}{x_2} \,\mbox{d}\bfx,\\
  a_{22}(u_2, v_2) \!&amp;=&amp;\! \int_\Omega (2\mu+\lambda)\dd{u_2}{x_2}\dd{v_2}{x_2} + \mu\dd{u_2}{x_1}\dd{v_2}{x_1} \,\mbox{d}\bfx,  \\
  l_{1}(v_1) \!&amp;=&amp;\!
  \int_{\Gamma_3} \!\!f_1 v_1 \,\mbox{d}S, \\
  l_{2}(v_2) \!&amp;=&amp;\!
  \int_{\Gamma_3} \!\!f_2 v_2 \,\mbox{d}S.
\end{eqnarray*}" /></p>
</div><p>Here, <img class="math" src="../../_images/math/2d8c833ed800824727cd7bd2fb9de1a12ad7e674.png" alt="\mu"/> and <img class="math" src="../../_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> are material constants (Lame coefficients) defined as</p>
<div class="math">
<p><img src="../../_images/math/d82a024f2893a62b7cd7d77520b42ca0357aa494.png" alt="\mu = \frac{E}{2(1+\nu)}, \ \ \ \ \  \lambda = \frac{E\nu}{(1+\nu)(1-2\nu)}," /></p>
</div><p>where <img class="math" src="../../_images/math/fa2fa899f0afb05d6837885523503a2d4df434f9.png" alt="E"/> is the Young modulus and <img class="math" src="../../_images/math/d6a7ccf879c4a4fe694033606332cb83806db296.png" alt="\nu"/> the Poisson ratio of the material. For
steel, we have <img class="math" src="../../_images/math/d2895c57a99b89aa3ad8a1970113b957d534187b.png" alt="E = 200"/> GPa and <img class="math" src="../../_images/math/cc6cbbd5bc525d5654189409431f002fa4427a5d.png" alt="\nu = 0.3"/>. The load is <img class="math" src="../../_images/math/24e21f30e9dad14bf6de5f509865803d85e3e6f3.png" alt="f = (0, 10^4)^T"/> N.</p>
<p>We begin with defining the function spaces for the two solution
components, <img class="math" src="../../_images/math/0559ffc8c62a08ff533f3fcd1a5c1713a520755d.png" alt="u_1"/> and <img class="math" src="../../_images/math/0725e2d5475070ba690e43acfb1adb66de9051fc.png" alt="u_2"/> (the <img class="math" src="../../_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x"/> and <img class="math" src="../../_images/math/092e364e1d9d19ad5fffb0b46ef4cc7f2da02c1c.png" alt="y"/> displacement). The boundary
conditions can be implemented as follows:</p>
<div class="highlight-python"><pre>// Boundary condition types.
BCType bc_types(int marker)
  { return (marker == 1) ? BC_ESSENTIAL : BC_NATURAL;; }

// Essential (Dirichlet) boundary condition values.
scalar essential_bc_values(int ess_bdy_marker, double x, double y)
  { return 0; }</pre>
</div>
<p>Next we create two displacement spaces:</p>
<div class="highlight-python"><pre>// Create x- and y- displacement spaces using default H1 shapesets.
H1Space xdisp(&amp;mesh, bc_types, essential_bc_values, P_INIT);
H1Space ydisp(&amp;mesh, bc_types, essential_bc_values, P_INIT);</pre>
</div>
<p>The WeakForm instance is initialized for a system of two equations:</p>
<div class="highlight-python"><pre>// initialize the weak formulation
WeakForm wf(2);
wf.add_matrix_form(0, 0, callback(bilinear_form_0_0), H2D_SYM);  // Note that only one symmetric part is
wf.add_matrix_form(0, 1, callback(bilinear_form_0_1), H2D_SYM);  // added in the case of symmetric bilinear
wf.add_matrix_form(1, 1, callback(bilinear_form_1_1), H2D_SYM);  // forms.
wf.add_vector_form_surf(0, callback(linear_form_surf_0), GAMMA_3_BDY);
wf.add_vector_form_surf(1, callback(linear_form_surf_1), GAMMA_3_BDY);</pre>
</div>
<p>In the registration of matrix and vector forms,
the block index 0, 0 means that bilinear_form_0_0() takes basis functions from
space 0 (x-displacement space) and test functions from space 0. The block index
0, 1 means that bilinear_form_0_1 takes basis functions from space 0 and test functions
from space 1 (y-displacement space), etc. This yields a 2x2 block structure in the
resulting matrix system.</p>
<p>Also explanation of the extra parameter H2D_SYM in add_matrix_form() is in order.
Since the two diagonal forms <img class="math" src="../../_images/math/18b49f4ed1eaf78a457483785c0ce3d80a47c0dc.png" alt="a_{11}"/> and <img class="math" src="../../_images/math/37f1c2fe37ec19c83eabedd7ec86959f660aa907.png" alt="a_{22}"/> are symmetric, i.e.,
<img class="math" src="../../_images/math/cc3b243dd0fc09d848ef2a50b4c86533729ad8d2.png" alt="a_{ii}(u,v) = a_{ii}(v,u)"/>, Hermes can be told to only evaluate them once for the
two cases <img class="math" src="../../_images/math/8ab694795097cd9f5cc0f0127b0bfbd764897946.png" alt="a_{ii}(u,v)"/> and <img class="math" src="../../_images/math/aa4bb4d15d9eef3a0462a5aec7b2db4e655193f7.png" alt="a_{ii}(v,u)"/> to speed up assembly. In fact, we should have
used the H2D_SYM flag already in the previous sections, since the form
<img class="math" src="../../_images/math/dfd44b79ba8f1fcb3861ee93132588683818af55.png" alt="a(u,v) = \nabla u \cdot \nabla v"/> was symmetric. Of course this is not the case
for all forms and so the default value of the fourth parameter of add_matrix_form()
is H2D_UNSYM.</p>
<p>The off-diagonal forms <img class="math" src="../../_images/math/b149fb490458c0852f5201b28f384379f8bf70d3.png" alt="a_{12}(u_2, v_1)"/> and <img class="math" src="../../_images/math/39c167059539d1fc6ef612d514e24bd2f2f07f23.png" alt="a_{21}(u_1, v_2)"/> are not
(and cannot) be symmetric, since their arguments come from different spaces in general.
However, we can see that <img class="math" src="../../_images/math/70b5c114972d4094ebf5c658e10c70bdaf333cae.png" alt="a_{12}(u, v) = a_{21}(v, u)"/>, i.e., the corresponding blocks
of the local stiffness matrix are transposes of each other. Here, the H2D_SYM flag
has a different effect: it tells Hermes to take the block of the local stiffness
matrix corresponding to the form <img class="math" src="../../_images/math/3f6bfb1f0a208187bed5a389462b7e45bb2a04c9.png" alt="a_{12}"/>, transpose it and copy it where a block
corresponding to <img class="math" src="../../_images/math/cd97e21d2e71d785c570ae8b343b3d5d8efef4f0.png" alt="a_{21}"/> would belong, without evaluating <img class="math" src="../../_images/math/cd97e21d2e71d785c570ae8b343b3d5d8efef4f0.png" alt="a_{21}"/> at all (this is why
we don&#8217;t add bilinear_form_1_0). This again speeds up the matrix assembly.
You can also use the flag H2D_ANTISYM, which moreover inverts the sign of the block.
This makes sense in the case where <img class="math" src="../../_images/math/a813a856c10096c63d0b1b80ecf80a0f937c738c.png" alt="a_{ij}(u, v) = -a_{ji}(v, u)"/>.</p>
<p>It is recommended that you start with the default (and safe) H2D_UNSYM flag for all
forms when developing your project, and only optimize the evaluation of the forms when
the code works well.</p>
<p>When the spaces and weak forms are ready, one can use the function solve_linear() to
assemble and solve the discrete problem:</p>
<div class="highlight-python"><pre>// Solve the linear problem.
Solution u_sln, v_sln;
solve_linear(Tuple&lt;Space *&gt;(&amp;u_space, &amp;v_space), &amp;wf,
             Tuple&lt;Solution*&gt;(&amp;u_sln, &amp;v_sln), matrix_solver);</pre>
</div>
<p>Von Mises stress can be visualized via the VonMises filter as follows:</p>
<div class="highlight-python"><pre>// Visualize the solution.
WinGeom* sln_win_geom = new WinGeom(0, 0, 800, 400);
ScalarView view("Von Mises stress [Pa]", sln_win_geom);
VonMisesFilter stress(Tuple&lt;MeshFunction*&gt;(&amp;u_sln, &amp;v_sln), lambda, mu);
view.show_mesh(false);
view.show(&amp;stress, H2D_EPS_HIGH, H2D_FN_VAL_0, &amp;u_sln, &amp;v_sln, 1.5e5);</pre>
</div>
<p>We will say more about visualization and Filters in a moment, after showing the long version of this example.</p>
<div class="section" id="long-version-of-example-08">
<h3>Long Version of Example 08<a class="headerlink" href="#long-version-of-example-08" title="Permalink to this headline">¶</a></h3>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/08-system-long">08-system-long</a>.</p>
<p>As in example 03, the long version of this example does not employ the function solve_linear(). Instead, after initializing the weak formulation, one initializes the LinearProblem class, selects a matrix solver, assembles the matrix problem, solves it, and translates the resulting coefficient vector into Solutions:</p>
<div class="highlight-python"><pre>// Initialize the linear problem.
LinearProblem lp(&amp;wf, Tuple&lt;Space *&gt;(&amp;u_space, &amp;v_space));

// Select matrix solver.
Matrix* mat; Vector* rhs; CommonSolver* solver;
init_matrix_solver(matrix_solver, ndof, mat, rhs, solver);

// Assemble stiffness matrix and rhs.
lp.assemble(mat, rhs);

// Solve the matrix problem.
if (!solver-&gt;solve(mat, rhs)) error ("Matrix solver failed.\n");

// Convert coefficient vector into a Solution.
Solution* u_sln = new Solution(&amp;u_space, rhs);
Solution* v_sln = new Solution(&amp;v_space, rhs);</pre>
</div>
</div>
</div>
<div class="section" id="visualization-and-filters">
<h2>Visualization and Filters<a class="headerlink" href="#visualization-and-filters" title="Permalink to this headline">¶</a></h2>
<p>In elasticity problems one often wants to see the material
stress, which is obtained by a formula that combines the derivatives
of the two displacement components.
Hermes implements postprocessing through Filters. Filter is a special class
which takes up to three Solutions, performs some computation and in the end acts
as another Solution (which can be visualized, passed into another Filter,
passed into a weak form, etc.). More advanced usage of Filters will be discussed
later. In elasticity examples we typically use the predefined VonMisesFilter:</p>
<div class="highlight-python"><pre>VonMisesFilter stress(Tuple&lt;MeshFunction*&gt;(u_sln, v_sln), lambda, mu);
view.show_mesh(false);
view.show(&amp;stress, H2D_EPS_HIGH);</pre>
</div>
<p>The second line tells Hermes not to display mesh edges.
The second parameter of show() is the visualization accuracy. It can have the
values H2D_EPS_LOW, H2D_EPS_NORMAL (default) and H2D_EPS_HIGH. This parameter
influences the number of linear triangles that Hermes uses to approximate
higher-order polynomial solutions within finite elements. Using linear
triangles is required by OpenGL, so Hermes at least performs automatic
adaptivity to reduce their number to a minimum. The above parameters
are used to set the accuracy of this piecewise-linear approximation.</p>
<p>The method show() has an optional third parameter to indicate whether
function values or partial derivatives should be displayed. For example,
H2D_FN_VAL_0 stands for the function value of solution component 0
(first solution component which in this case is the VonMises stress).
H2D_FN_VAL_1 would mean the function value of the second solution component
(relevant for vector-valued <img class="math" src="../../_images/math/d015ab117f4c71f12005755e60a077278cd306ec.png" alt="Hcurl"/> or <img class="math" src="../../_images/math/668dcbe361338eb7374da6eff016bb0ffacf9498.png" alt="Hdiv"/> elements only),
H2D_FN_DX_0 means the x-derivative of the first solution component, etc.</p>
<p>Finally, in elasticity problems it may be desirable to deform the computational
domain according to the calculated displacements. The method View::show() has
additional three optional parameters for this:</p>
<div class="highlight-python"><pre>VonMisesFilter stress(Tuple&lt;MeshFunction*&gt;(&amp;u_sln, &amp;v_sln), lambda, mu);
view.show(&amp;stress, H2D_EPS_HIGH, H2D_FN_VAL_0, &amp;u_sln, &amp;v_sln, 1.5e5);</pre>
</div>
<p>Here the fourth and fifth parameters are the displacement components used to
distort the domain geometry, and the sixth parameter is a scaling factor to multiply the
displacements. Of course, the color map still shows the Von Mises stress as before.</p>
<div align="center" class="align-center"><img alt="Elastic stress plotted on deformed domain." class="align-center" src="../../_images/mises1.png" style="width: 550px; height: 300px;" /></div>
</div>
<div class="section" id="time-dependent-problems-09">
<h2>Time-Dependent Problems (09)<a class="headerlink" href="#time-dependent-problems-09" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/09-timedep">09-timedep</a>.</p>
<p>This section describes the implementation of a simple time-dependent
heat transfer model that describes, in a naive approximation, how the St. Vitus cathedral
in Prague responds to changes in the surrounding air temperature
during one 24-hour cycle. The geometry is shown below:</p>
<div align="center" class="align-center"><img alt="Model geometry and temperature distribution after 24 hours." class="align-center" src="../../_images/vitus1.png" style="width: 400px; height: 500px;" /></div>
<p>We will solve the standard heat transfer equation</p>
<div class="math" id="equation-eqvit1">
<p><span class="eqno">(5)</span><img src="../../_images/math/58e89ff50559ff5faa30d190691bfbd1d0e7c1b1.png" alt="c \varrho\frac{\partial T}{\partial t} - \lambda \Delta T = 0" /></p>
</div><p>equipped with a Dirichlet condition</p>
<div class="math">
<p><img src="../../_images/math/dc4809dc5bc1de42d9b7ae9ea53a9d031b65496b.png" alt="T = T_{init}" /></p>
</div><p>on the bottom edge <img class="math" src="../../_images/math/38de19d6a531815e00dd1ba74a160935091ab0f5.png" alt="\Gamma_{ground}"/> and a Newton condition</p>
<div class="math">
<p><img src="../../_images/math/3574ac4d29d413a5ad1850c2a039e04ab1039a68.png" alt="\frac{\partial T}{\partial \nu} = \alpha(T_{ext}(t) - T)" /></p>
</div><p>on the rest of the boundary <img class="math" src="../../_images/math/eb0adc23facd966b8f446cfe9f6e94ea855f2b06.png" alt="\Gamma_{air}"/>. Here, <img class="math" src="../../_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> is the heat capacity of the material,
<img class="math" src="../../_images/math/e7fe4fc87a1b38d0b6f1f34da3c84a3fd3cb64c6.png" alt="\varrho"/> the material density, <img class="math" src="../../_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> the thermal conductivity,
<img class="math" src="../../_images/math/8843278e1fa4353f948b2d74780348d2f927542e.png" alt="T_{init}"/> the fixed temperature on the
ground (same as the initial temperature of the building), and <img class="math" src="../../_images/math/10f32377ac67d94f764f12a15ea987e88c85d3e1.png" alt="\alpha"/>
the heat transfer coefficient
between the building and the surrounding air. The surrounding air temperature
<img class="math" src="../../_images/math/604389d901d11dca73779c99567110b594bf3f59.png" alt="T_{ext}"/> is time-dependent of the form</p>
<div class="math">
<p><img src="../../_images/math/8cbd3cec2481175cc37aa1d9c3010e6ab276b9e5.png" alt="T_{ext}(t) = T_{init} + 10\sin(2\pi t/T_{final})," /></p>
</div><p>where <img class="math" src="../../_images/math/c267e068279a2dd54472b3dc68d481174c51bc40.png" alt="T_{final}"/> is 24 hours (translated into seconds).</p>
<p>Equation <a href="#equation-eqvit1">(5)</a> is also equipped with an initial condition of the
form</p>
<div class="math">
<p><img src="../../_images/math/5ec047988e245d1172e255b4be8520f4a2fd399f.png" alt="T(x,y,0) = T_{init}(x,y) \ \ \ \mbox{in} \ \Omega." /></p>
</div><p>For simplicity we will use the implicit Euler method with a constant
time step <img class="math" src="../../_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau"/>, which transforms equation <a href="#equation-eqvit1">(5)</a> into</p>
<div class="math">
<p><img src="../../_images/math/0e392fa2ae44d3b56e15e85364bed9c57ed4a63c.png" alt="c \varrho\frac{T^{n+1} - T^n}{\tau} - \lambda \Delta T^{n+1} = 0." /></p>
</div><p>The corresponding weak formulation is</p>
<div class="math">
<p><img src="../../_images/math/8cc83f877977aa419fbe08672d8a736950085631.png" alt="\int_{\Omega} c \varrho\frac{T^{n+1}}{\tau} + \int_{\Omega} \lambda \nabla T^{n+1}\cdot \nabla v + \int_{\Gamma_{air}} \alpha \lambda T^{n+1}v = \int_{\Omega} c \varrho\frac{T^{n}}{\tau} + \int_{\Gamma_{air}} \alpha \lambda T_{ext}(t^{n+1})v." /></p>
</div><p>The implementation starts by defining the
boundary condition types:</p>
<div class="highlight-python"><pre>BCType bc_types(int marker)
{
  if (marker == bdy_ground) return BC_ESSENTIAL;
  else return BC_NATURAL;
}</pre>
</div>
<p>and values:</p>
<div class="highlight-python"><pre>scalar essential_bc_values(int ess_bdy_marker, double x, double y)
{
  if (ess_bdy_marker == bdy_ground) return T_INIT;
}</pre>
</div>
<p>Then the space for the temperature <img class="math" src="../../_images/math/2554b6496c3b678897e9b060ef00aa9f0a7d7ece.png" alt="T"/> is set up:</p>
<div class="highlight-python"><pre>// Initialize an H1 space with default shepeset.
H1Space space(&amp;mesh, bc_types, essential_bc_values, P_INIT);
int ndof = get_num_dofs(&amp;space);</pre>
</div>
<p>Bilinear and linear forms are defined as follows:</p>
<div class="highlight-python"><pre>template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return HEATCAP * RHO * int_u_v&lt;Real, Scalar&gt;(n, wt, u, v) / TAU +
         LAMBDA * int_grad_u_grad_v&lt;Real, Scalar&gt;(n, wt, u, v);
}

template&lt;typename Real, typename Scalar&gt;
Scalar linear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return HEATCAP * RHO * int_u_v&lt;Real, Scalar&gt;(n, wt, ext-&gt;fn[0], v) / TAU;
}

template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form_surf(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return LAMBDA * ALPHA * int_u_v&lt;Real, Scalar&gt;(n, wt, u, v);
}

template&lt;typename Real, typename Scalar&gt;
Scalar linear_form_surf(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return LAMBDA * ALPHA * temp_ext(TIME) * int_v&lt;Real, Scalar&gt;(n, wt, v);
}</pre>
</div>
<p>Next we need to initialize the previous solution tsln with the initial condition <img class="math" src="../../_images/math/8843278e1fa4353f948b2d74780348d2f927542e.png" alt="T_{init}"/>.
Besides holding the finite element solution, the Solution class
can be forced to return zero, to return a constant, or to return an arbitrary function
using the methods set_zero(), set_const() and set_exact(), respectively.
Here we simply call set_const() and supply the initial temperature:</p>
<div class="highlight-python"><pre>// Set constant initial condition.
Solution tsln;
tsln.set_const(&amp;mesh, T_INIT);</pre>
</div>
<p>The weak forms are registered as follows:</p>
<div class="highlight-python"><pre>// Initialize weak formulation.
WeakForm wf();
wf.add_matrix_form(bilinear_form&lt;double, double&gt;, bilinear_form&lt;Ord, Ord&gt;);
wf.add_matrix_form_surf(bilinear_form_surf&lt;double, double&gt;, bilinear_form_surf&lt;Ord, Ord&gt;, bdy_air);
wf.add_vector_form(linear_form&lt;double, double&gt;, linear_form&lt;Ord, Ord&gt;, H2D_ANY, &amp;tsln);
wf.add_vector_form_surf(linear_form_surf&lt;double, double&gt;, linear_form_surf&lt;Ord, Ord&gt;, bdy_air);</pre>
</div>
<p>Next, the LinearProblem class and the matrix solver structures are initialized:</p>
<div class="highlight-python"><pre>// Initialize the linear problem.
LinearProblem lp(&amp;wf, &amp;space);

// Initialize matrix solver.
Matrix* mat; Vector* rhs; CommonSolver* solver;
init_matrix_solver(matrix_solver, ndof, mat, rhs, solver);</pre>
</div>
<p>We are now ready to start the iterative process. Since the stiffness matrix does
not depend on the solution, it only needs to be assembled once in the first time
step. For all remaining time steps it will be the same, and we just need to
re-construct the load vector. This is done via the Boolean variable rhsonly
which is set to false before the time stepping begins. For completeness, we show
the entire time stepping loop below:</p>
<div class="highlight-python"><pre>bool rhsonly = false;
for(int ts = 1; ts &lt;= nsteps; ts++)
{
  info("---- Time step %d, time %3.5f, ext_temp %g", ts, TIME, temp_ext(TIME));

  // Assemble stiffness matrix and rhs.
  lp.assemble(mat, rhs, rhsonly);
  rhsonly = true;

  // Solve the matrix problem.
  if (!solver-&gt;solve(mat, rhs)) error ("Matrix solver failed.\n");

  // Update tsln.
  tsln.set_coeff_vector(&amp;space, rhs);

  // Update the time variable.
  TIME += TAU;

  // Visualize the solution.
  sprintf(title, "Time %3.2f, exterior temperature %3.5f", TIME, temp_ext(TIME));
  Tview.set_title(title);
  Tview.show(&amp;tsln);
}</pre>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">Hermes2D Tutorial: Part I (Linear Problems)</a><ul>
<li><a class="reference external" href="#finite-element-mesh-01">Finite Element Mesh (01)</a><ul>
<li><a class="reference external" href="#mesh-file-format">Mesh File Format</a></li>
<li><a class="reference external" href="#nurbs-curves">NURBS Curves</a></li>
<li><a class="reference external" href="#loading-mesh">Loading Mesh</a></li>
</ul>
</li>
<li><a class="reference external" href="#setting-up-finite-element-space-02">Setting Up Finite Element Space (02)</a></li>
<li><a class="reference external" href="#solving-poisson-equation-03">Solving Poisson Equation (03)</a></li>
<li><a class="reference external" href="#short-and-long-versions-of-examples">Short and Long Versions of Examples</a></li>
<li><a class="reference external" href="#boundary-conditions-04-05-06">Boundary Conditions (04, 05, 06)</a><ul>
<li><a class="reference external" href="#dirichlet-bc">Dirichlet BC</a></li>
<li><a class="reference external" href="#neumann-bc">Neumann BC</a></li>
<li><a class="reference external" href="#newton-bc">Newton BC</a></li>
</ul>
</li>
<li><a class="reference external" href="#determination-of-quadrature-orders-in-weak-forms">Determination of Quadrature Orders in Weak Forms</a><ul>
<li><a class="reference external" href="#automatic-determination-of-quadrature-order">Automatic determination of quadrature order</a></li>
<li><a class="reference external" href="#manual-determination-of-quadrature-order">Manual determination of quadrature order</a></li>
</ul>
</li>
<li><a class="reference external" href="#general-2nd-order-linear-equation-07">General 2nd-Order Linear Equation (07)</a></li>
<li><a class="reference external" href="#systems-of-equations-08">Systems of Equations (08)</a><ul>
<li><a class="reference external" href="#long-version-of-example-08">Long Version of Example 08</a></li>
</ul>
</li>
<li><a class="reference external" href="#visualization-and-filters">Visualization and Filters</a></li>
<li><a class="reference external" href="#time-dependent-problems-09">Time-Dependent Problems (09)</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="../first_pull_request.html"
                                  title="previous chapter">How to Submit Your First Pull Request</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="tutorial-2.html"
                                  title="next chapter">Hermes2D Tutorial: Part II (Automatic Adaptivity)</a></p>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial-2.html" title="Hermes2D Tutorial: Part II (Automatic Adaptivity)"
             >next</a> |</li>
        <li class="right" >
          <a href="../first_pull_request.html" title="How to Submit Your First Pull Request"
             >previous</a> |</li>
        <li><a href="../../index.html">Content</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, hp-FEM group at UNR.
      Last updated on Nov 11, 2010.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  </body>
</html>