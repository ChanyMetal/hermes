<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Hermes2D Tutorial: Part II (Automatic Adaptivity) &mdash; Hermes2D Documentation</title>
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Hermes2D Documentation" href="../../index.html" />
    <link rel="next" title="Hermes2D Tutorial: Part III (Nonlinear Problems)" href="tutorial-3.html" />
    <link rel="prev" title="Hermes2D Tutorial: Part I (Linear Problems)" href="tutorial-1.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial-3.html" title="Hermes2D Tutorial: Part III (Nonlinear Problems)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial-1.html" title="Hermes2D Tutorial: Part I (Linear Problems)"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">Content</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="hermes2d-tutorial-part-ii-automatic-adaptivity">
<h1>Hermes2D Tutorial: Part II (Automatic Adaptivity)<a class="headerlink" href="#hermes2d-tutorial-part-ii-automatic-adaptivity" title="Permalink to this headline">¶</a></h1>
<p>So far we have not paid any attention to the accuracy of the results. In general,
a computation on a fixed mesh is not likely to be very accurate. There is a need
for <em>adaptive mesh refinement (AMR)</em> that improves the quality of the approximation
by refining mesh elements or increases the polynomial degree of approximation
where the approximation is bad.</p>
<div class="section" id="adaptive-h-fem-and-hp-fem">
<h2>Adaptive h-FEM and hp-FEM<a class="headerlink" href="#adaptive-h-fem-and-hp-fem" title="Permalink to this headline">¶</a></h2>
<p>In traditional low-order FEM, refining an element is not algorithmically complicated,
and so the most difficult part is to find out what elements should be
refined. To do this, people employ various techniques ranging from rigorous
guaranteed a-posteriori error estimates to heuristic criteria such as residual
error indicators, error indicators based on steep gradients, etc. Unfortunately,
none of these approaches is suitable for real-life multiphysics coupled problems
or higher-order finite element methods: Rigorous guaranteed error
estimates only exist for very simple problems (such as linear elliptic PDE),
and moreover only for low-order finite elements (such as piecewise linear
approximations). Note that virtually no a-posteriori error estimates capable of
guiding automatic hp-adaptivity are available even for simplest elliptic problems,
this will be discussed in a moment.
The heuristic techniques listed above are not employed in Hermes since they may fail
in non-standard situations, and because they lack a transparent relation to the
true approximation error.</p>
<p>Adaptive low-order FEM is known to be notoriously inefficient, and practitioners
are rightfully skeptical of it. The reason is its extremely slow convergence
that makes large computations virtually freeze without getting anywhere.
This is illustrated in the following graph that compares a typical convergence of
adaptive FEM with linear elements, adaptive FEM with quadratic elements, and
adaptive hp-FEM:</p>
<div align="center" class="align-center"><img alt="Typical convergence curves for adaptive linear FEM, quadratic FEM, and *hp*-FEM." class="align-center" src="src/hermes2d/img/benchmark-lshape/conv_dof.png" style="width: 600px; height: 400px;" /></div>
<p>Note that the linear FEM would need in the order of 1,000,000,000,000,000,000 degrees of freedom
(DOF) to reach a level of accuracy where the hp-FEM is with less than 10,000 DOF.
These convergence curves are typical representative examples, confirmed with
many numerical experiments of independent researchers, and supported with
theory. The horizontal axis shows (in linear scale) the number of degrees of freedom
(= size of the stiffness matrix) that increases during automatic adaptivity. The
vertical one shows the approximation error (in logarithmic scale). Note that in all
three cases, the convergence is similar during a short initial phase. However, with
the hp-FEM the convergence becomes faster and faster as the adaptivity progresses. Note that
low-order FEM is doomed to such slow convergence by its poor approximation properties -
this cannot be fixed no matter how smart the adaptivity algorithm might be.</p>
<p>In order to obtain fast, usable adaptivity (the red curve), one
has to resort to adaptive <em>hp</em>-FEM. The <em>hp</em>-FEM takes advantage of
the following facts:</p>
<ul class="simple">
<li>Large high-degree elements approximate smooth parts of solution <em>much</em> better than small linear ones.
The benchmark <a class="reference external" href="http://hpfem.org/hermes/doc/src/hermes2d/benchmarks.html#smooth-iso-elliptic">smooth-iso</a>
illustrates this - spend a few minutes to check it out, the results are truly impressive. In the
Hermes2D repository, it can be found in the directory
<a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/benchmarks">benchmarks/</a>.</li>
<li>This holds the other way where the solution is not smooth, i.e., singularities,
steep gradients, oscillations and such are approximated best using locally small
low-order elements.</li>
<li>In order to capture efficiently anisotropic solution behavior, one needs adaptivity algorithms
that can refine meshes anisotropically both in <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/> and <img class="math" src="../../_images/math/36f73fc1312ee0349b3f3a0f3bd9eb5504339011.png" alt="p"/>. Often this is the case with
boundary layers (viscous flows, singularly perturbed problems, etc.). This is illustrated
in  benchmarks
<a class="reference external" href="http://hpfem.org/hermes/doc/src/hermes2d/benchmarks.html#smooth-aniso-x-elliptic">smooth-aniso-x</a> and
<a class="reference external" href="http://hpfem.org/hermes/doc/src/hermes2d/benchmarks.html#boundary-layer-elliptic">boundary layer</a>. However,
solutions without boundary layers can have significant anisotropic behavior too, as illustrated
in benchmark  <a class="reference external" href="http://hpfem.org/hermes/doc/src/hermes2d/benchmarks.html#line-singularity-elliptic">line singularity</a>.</li>
</ul>
<div class="section" id="large-number-of-possible-element-refinements-in-hp-fem">
<h3>Large number of possible element refinements in &#8216;hp&#8217;-FEM<a class="headerlink" href="#large-number-of-possible-element-refinements-in-hp-fem" title="Permalink to this headline">¶</a></h3>
<p>Automatic adaptivity in the <em>hp</em>-FEM is substantially different from adaptivity
in low-order FEM, since every element can be refined in many different ways.
The following figure shows several illustrative refinement candidates for a fourth-order element.</p>
<div align="center" class="align-center"><img alt="Examples of *hp*-refinements." class="align-center" src="../../_images/refinements.png" style="width: 650px; height: 300px;" /></div>
<p>Of course, the number of possible element refinements is implementation-dependent.
In general it is very low in <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/> or <img class="math" src="../../_images/math/36f73fc1312ee0349b3f3a0f3bd9eb5504339011.png" alt="p"/> adaptivity, much higher in <img class="math" src="../../_images/math/e158fefb7519a21c5a175711642a9c9295ef314f.png" alt="hp"/> adaptivity,
and it rises even more when anisotropic refinements are enabled. This is why Hermes
has eight different adaptivity options P_ISO, P_ANISO, H_ISO, H_ANISO,
HP_ISO, HP_ANISO_P, HP_ANISO_H, HP_ANISO. In this ordering, usually P_ISO yields the
worst results and HP_ANISO the best. In the most general HP_ANISO
option, around 100 refinement candidates for each element are considered.
Naturally, the adaptivity algorithm takes progressively more time as more
refinement candidates are considered. The difference between the HP_ANISO_H
option (next best to HP_ANISO) and HP_ANISO is quite significant. So, this is
where the user has to make a choice based on his a-priori knowledge of the
solution behavior.</p>
<p>Due to the large number of refinement options, classical error estimators (that
provide a constant error estimate per element) cannot be used to guide automatic
<em>hp</em>-adaptivity. For this, one needs to know the <em>shape</em> of the
approximation error.</p>
<p>In analogy to the most successful adaptive ODE solvers,
Hermes uses a pair of approximations with different orders of accuracy to obtain
this information: <em>coarse mesh solution</em> and
<em>fine mesh solution</em>. The initial coarse mesh is read from the mesh file,
and the initial fine mesh is created through its global refinement both in
<img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/> and <img class="math" src="../../_images/math/36f73fc1312ee0349b3f3a0f3bd9eb5504339011.png" alt="p"/>.
The fine mesh solution is the approximation of interest both during the adaptive
process and at the end of computation. The coarse mesh solution represents its
low-order part. In all adaptivity examples in Hermes, the coarse mesh solution
can be turned off and a global orthogonal projection of the fine mesh solution
on the coarse mesh can be used instead. In most cases, this yields a better
convergence behavior than using the coarse mesh solve (and the projection
problem is always linear and better conditioned than solving on the coarse mesh).</p>
<p>Note that this approach is PDE independent, which is truly great for multiphysics
coupled problems. Currently, Hermes does not use a single analytical error estimate
or any other technique that would narrow down its applicability to just some
equations or just low-order FEM.</p>
<p>The obvious disadvantage of the Hermes approach to automatic adaptivity is its higher
computational cost, especially in 3D. We are aware of this fact and would not mind
at all replacing it with some cheaper technique (as long as it also is PDE-independent,
works for elements of high orders, and can be successfully used to guide <em>hp</em>-adaptivity).
So far, however, no alternatives meeting these criteria exist yet to our best knowledge.</p>
</div>
</div>
<div class="section" id="understanding-convergence-rates">
<h2>Understanding Convergence Rates<a class="headerlink" href="#understanding-convergence-rates" title="Permalink to this headline">¶</a></h2>
<p>Hermes provides convergence graphs for every adaptive computation. Therefore,
let us spend a short moment explaining their meaning.
The classical notion of <img class="math" src="../../_images/math/06f469c725896b6d6acb62e4463881ce0986efec.png" alt="O(h^p)"/> convergence rate is related to sequences of
uniform meshes with a gradually decreasing diameter <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/>. In <img class="math" src="../../_images/math/96ab646de7704969b91c76a214126b45f2b07b25.png" alt="d"/> spatial dimensions,
the diameter <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/> of a uniform mesh is related to the number of degrees of freedom <img class="math" src="../../_images/math/fc97ef67268cd4e91bacdf12b8901d7036c9a056.png" alt="N"/>
through the relation</p>
<div class="math">
<p><img src="../../_images/math/271d3e7f0632fa3192792c8e3f45efceff4408f4.png" alt="h = O(N^{-p/d})." /></p>
</div><p>Therefore a slope of <img class="math" src="../../_images/math/55f97cabaa3322b37f23c202547879913faa121e.png" alt="-p/d"/> on the log-log scale means that <img class="math" src="../../_images/math/2becd962cb2cea053ef3d10d6f8b616f8d2b3316.png" alt="err \approx O(N^{-p/d})"/>
or <img class="math" src="../../_images/math/3de4f3e8e8d16fb120be8c86828c9e78fd5a5ae1.png" alt="err \approx O(h^p)"/>. When local refinements are enabled, the meaning of <img class="math" src="../../_images/math/06f469c725896b6d6acb62e4463881ce0986efec.png" alt="O(h^p)"/>
convergence rate loses its meaning, and one should switch to convergence in terms of
the number of degrees of freedom (DOF) or CPU time - Hermes provides both.</p>
<div class="section" id="algebraic-convergence-of-adaptive-fem">
<h3>Algebraic convergence of adaptive <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/>-FEM<a class="headerlink" href="#algebraic-convergence-of-adaptive-fem" title="Permalink to this headline">¶</a></h3>
<p>When using elements of degree <img class="math" src="../../_images/math/36f73fc1312ee0349b3f3a0f3bd9eb5504339011.png" alt="p"/>, the convergence rate of adaptive <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/>-FEM will not exceed the
one predicted for uniformly refined meshes (this can be explained using
mathematical analysis). Nevertheless, the convergence may be faster due to a different
constant in front of the <img class="math" src="../../_images/math/1372c91cc89c9bbd95f4176704e9b3a882f50a3d.png" alt="h^p"/> term. This is illustrated in the following two figures,
both of which are related to a 2D problem with known exact solution. The first pair of
graphs corresponds to adaptive <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/>-FEM with linear elements. The slope on the log-log
graph is -1/2 which means first-order convergence, as predicted by theory.</p>
<div align="center" class="align-center"><img alt="Convergence graph." class="align-center" src="../../_images/layer_h1.png" style="width: 600px; height: 450px;" /></div>
<p>The next pair of convergence graphs corresponds to adaptive <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/>-FEM with quadratic elements.
The slope on the log-log graph is -1, which means that the convergence is quadratic as
predicted by theory.</p>
<div align="center" class="align-center"><img alt="Convergence graph." class="align-center" src="../../_images/layer_h2.png" style="width: 600px; height: 450px;" /></div>
<p>Note that one always should look at the end of the convergence curve, not at the
beginning. The automatic adaptivity in Hermes is guided with the so-called
<em>reference solution</em>, which is an approximation on a globally-refined mesh.
In early stages of adaptivity, the reference solution and in turn also the error
estimate usually are not sufficiently accurate to deliver the expected convergence
rates.</p>
</div>
<div class="section" id="exponential-convergence-of-adaptive-fem">
<h3>Exponential convergence of adaptive <img class="math" src="../../_images/math/e158fefb7519a21c5a175711642a9c9295ef314f.png" alt="hp"/>-FEM<a class="headerlink" href="#exponential-convergence-of-adaptive-fem" title="Permalink to this headline">¶</a></h3>
<p>It is predicted by theory that adaptive <img class="math" src="../../_images/math/e158fefb7519a21c5a175711642a9c9295ef314f.png" alt="hp"/>-FEM should attain
exponential convergence rate. This means that the slope of the
convergence graph is steadily increasing, as shown in the
following figure.</p>
<div align="center" class="align-center"><img alt="Convergence graph." class="align-center" src="../../_images/aniso-hp.png" style="width: 600px; height: 450px;" /></div>
<p>While this often is the case with adaptive <img class="math" src="../../_images/math/e158fefb7519a21c5a175711642a9c9295ef314f.png" alt="hp"/>-FEM, there are
problems whose difficulty is such that the convergence is not
exponential. Or at least not during a long pre-asymptotic
stage of adaptivity. This may happen, for example, when the solution
contains an extremely strong singularity. Then basically all error
is concentrated there, and all adaptive methods will do the same,
which is to throw into the singularity as many small low-order
elements as possible. Then the convergence of adaptive <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/>-FEM
and <img class="math" src="../../_images/math/e158fefb7519a21c5a175711642a9c9295ef314f.png" alt="hp"/>-FEM may be very similar (usually quite poor).</p>
</div>
<div class="section" id="estimated-vs-exact-convergence-rates">
<h3>Estimated vs. exact convergence rates<a class="headerlink" href="#estimated-vs-exact-convergence-rates" title="Permalink to this headline">¶</a></h3>
<p>Whenever exact solution is available, Hermes provides both
estimated error (via the reference solution) as well as the
exact error. Thus the user can see the quality of the
error estimate. Note that the estimated error usually is
slightly less than the exact one, but during adaptivity
they quickly converge together and become virtually identical.
This is shown in the figure below.</p>
<div align="center" class="align-center"><img alt="Convergence graph to the Layer benchmark." class="align-center" src="../../_images/layer-hp.png" style="width: 600px; height: 450px;" /></div>
<p>In problems with extremely strong singularities the difference between the
exact and estimated error can be significant. This is illustrated in the
following graph that belongs to the benchmark
<a class="reference external" href="http://hpfem.org/hermes/doc/src/hermes2d/benchmarks.html#kellogg-elliptic">kellogg</a>.</p>
<blockquote>
<div align="center" class="align-center"><img alt="Convergence graph to the Kellogg benchmark." class="align-center" src="src/hermes2d/img/benchmark-kellogg/kellogg-conv.png" style="width: 600px; height: 450px;" /></div>
</blockquote>
</div>
</div>
<div class="section" id="electrostatic-micromotor-problem-10">
<h2>Electrostatic Micromotor Problem (10)<a class="headerlink" href="#electrostatic-micromotor-problem-10" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/10-adapt">10-adapt</a>. Long version: <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/10-adapt-long">10-adapt-long</a>.</p>
<p>Let us demonstrate the use of adaptive h-FEM and hp-FEM on a linear elliptic problem
describing an electrostatic micromotor. This is a MEMS device free of any coils, and
thus (as opposed to classical electromotors) resistive to strong electromagnetic waves.</p>
<p>The following figure shows a symmetric half of the domain <img class="math" src="../../_images/math/9e2b196e9b7e57d1ec99f6534c581ea9759d2170.png" alt="\Omega"/>
(dimensions need to be scaled with <img class="math" src="../../_images/math/ba4c550ee9912a2a4ac806ce96ae8de9f6f7bf6d.png" alt="10^{-5}"/> and are in meters):</p>
<div align="center" class="align-center"><img alt="Computational domain for the micromotor problem." class="align-center" src="../../_images/micromotor.png" style="width: 550px; height: 400px;" /></div>
<p>The subdomain <img class="math" src="../../_images/math/1705dcf5b6ed693e2aaea2fda973ea0b976433db.png" alt="\Omega_2"/> represents the moving part of the domain and the area bounded by <img class="math" src="../../_images/math/1169b5ab2cbc837edbec8298a9a56d23dfedca02.png" alt="\Gamma_2"/>
represents the electrodes that are fixed. The distribution of the electrostatic potential <img class="math" src="../../_images/math/921aade3100afbc11d0d13f71cdd7e68d83ad52e.png" alt="\varphi"/> is governed by the equation</p>
<div class="math">
<p><img src="../../_images/math/28e291c371e2ca4d02178fff85496d29f1ae8201.png" alt="-\nabla\cdot\left(\epsilon_r\nabla\varphi\right) = 0," /></p>
</div><p>equipped with the Dirichlet boundary conditions</p>
<div class="math">
<p><img src="../../_images/math/f31ffc5d9ab154aa51f67aa0aa44f98df091b3d6.png" alt="\varphi = 0 V \ \ \ \ \ \mbox{on}\ \Gamma_1," /></p>
</div><div class="math">
<p><img src="../../_images/math/cb88e749897aa8680d87f6869989523f7861ef4c.png" alt="\varphi = 50 V \ \ \ \ \mbox{on}\ \Gamma_2." /></p>
</div><p>The relative permittivity <img class="math" src="../../_images/math/32a47e228de0d99659f6b85e5646ffc3722b75f6.png" alt="\epsilon_r"/> is piecewise-constant, <img class="math" src="../../_images/math/c03402f91695a05406516bdcf8a3f58bf2e8e59d.png" alt="\epsilon_r = 1"/> in <img class="math" src="../../_images/math/25c056f01b2d920f07a2a9bee3a455aa739c218a.png" alt="\Omega_1"/> and
<img class="math" src="../../_images/math/976268af683b85c024e9b312a2a08b6490be0e48.png" alt="\epsilon_r = 10"/> in <img class="math" src="../../_images/math/1705dcf5b6ed693e2aaea2fda973ea0b976433db.png" alt="\Omega_2"/>. The weak formulation reads</p>
<div class="math">
<p><img src="../../_images/math/341724b8de6d567fc3ae3bc9194fc485a56bca02.png" alt="\int_\Omega \epsilon_r \nabla u \cdot \nabla v \dx = 0." /></p>
</div><p>The piecewise constant parameter <img class="math" src="../../_images/math/32a47e228de0d99659f6b85e5646ffc3722b75f6.png" alt="\epsilon_r"/> is handled by defining two bilinear forms in the code, one for
<img class="math" src="../../_images/math/25c056f01b2d920f07a2a9bee3a455aa739c218a.png" alt="\Omega_1"/> and the other for <img class="math" src="../../_images/math/1705dcf5b6ed693e2aaea2fda973ea0b976433db.png" alt="\Omega_2"/>. The two different materials are distinguished by different
element markers OMEGA_1 = 1 and OMEGA_2 = 2 in the mesh file, and two different weak forms are assigned
to the corresponding markers during the registration of the forms:</p>
<div class="highlight-python"><pre>// Initialize the weak formulation.
WeakForm wf;
wf.add_matrix_form(callback(biform1), H2D_SYM, OMEGA_1);
wf.add_matrix_form(callback(biform2), H2D_SYM, OMEGA_2);</pre>
</div>
<div class="section" id="refinement-selector">
<h3>Refinement selector<a class="headerlink" href="#refinement-selector" title="Permalink to this headline">¶</a></h3>
<p>The principal part of the example is the main adaptivity loop. However, before the loop is entered,
a refinement selector should be initialized:</p>
<div class="highlight-python"><pre>H1ProjBasedSelector selector(CAND_LIST, CONV_EXP, H2DRS_DEFAULT_ORDER);</pre>
</div>
<p>The selector is used by the class H1Adapt to determine how an element should be refined. For that purpose, the selector does following steps:</p>
<ol class="arabic simple">
<li>It generates candidates (proposed refinements).</li>
<li>It estimates their local errors by projecting the reference solution onto their FE spaces.</li>
<li>It calculates the number of degree of freedom (DOF) contributed by each candidate.</li>
<li>It calculates a score for each candidate, and sorts them according to their scores.</li>
<li>It selects a candidate with the highest score. If the next candidate has almost the same score and symmetric mesh is
preferred, it skips both of them. More detailed explanation of this will follow.</li>
</ol>
<p>By default, the score is</p>
<div class="math">
<p><img src="../../_images/math/134a4dcd645581efea9a6b218bdb7a3a19cca2a9.png" alt="s = \frac{\log_{10} e_0 - \log_{10} e}{(d_0 - d)^\xi}," /></p>
</div><p>where <img class="math" src="../../_images/math/a3a59bb1293ee3f6dec19de4019a7178874219ae.png" alt="e"/> and <img class="math" src="../../_images/math/96ab646de7704969b91c76a214126b45f2b07b25.png" alt="d"/> are an estimated error and an estimated number of DOF of a candidate respectively, <img class="math" src="../../_images/math/a548744a86ddf548c3d3859475171cbbf62d17dc.png" alt="e_0"/> and <img class="math" src="../../_images/math/b5623ee18f045ea1ed3d240690fc7f54892e60a6.png" alt="d_0"/> are an estimated error and an estimated number of DOF of the examined element respectively, and <img class="math" src="../../_images/math/ccfd1641d037d427d9dbf42cdd54b485a03eafe9.png" alt="\xi"/> is a convergence exponent.</p>
<p>The first parameter <tt class="docutils literal"><span class="pre">CAND_LIST</span></tt> specifies which candidates are generated. In a case of quadrilaterals, all possible values and considered candidates are summarized in the following table:</p>
<div align="center" class="align-center"><img alt="Candidates generated for a given candidate list." class="align-center" src="../../_images/cand_list.quads.png" /></div>
<p>The second parameter <tt class="docutils literal"><span class="pre">CONV_EXP</span></tt> is a convergence exponent used to calculate the score.</p>
<p>The third parameter specifies the the maximum considered order used in the resulting refinement. In this case, a constant <tt class="docutils literal"><span class="pre">H2DRS_DEFAULT_ORDER</span></tt> is used. The constant is defined by Hermes2D library and it corresponds to the maximum order supported by the selector. In this case, this is 9.</p>
<p>Furthermore, the selector allows you to weight errors though a method set_error_weights(). Error weights are applied before the error of a candidate is passed to the calculation of the score. Through this method it is possible to set a preference for a given type of a candidate, i.e., H-candidate, P-candidate, and ANISO-candidate. The error weights can be set anytime and setting error weights to appropriate values can lead to a lower number of DOF. However, the best values of weights depend on a solved problem.</p>
<p>In this particular case, a default error weights are used. The default weights prefer the P-candidate and they are defined as:</p>
<ul class="simple">
<li>H-candidate weight: <img class="math" src="../../_images/math/84b3667cba1eb8400b3eb675a77250b0953d3faa.png" alt="2.0"/> (see a constant <tt class="docutils literal"><span class="pre">H2DRS_DEFAULT_ERR_WEIGHT_H</span></tt>)</li>
<li>P-candidate weight: <img class="math" src="../../_images/math/3e3e80aa2084dcbf7d73fcca88861e3830beb8fc.png" alt="1.0"/> (see a constant <tt class="docutils literal"><span class="pre">H2DRS_DEFAULT_ERR_WEIGHT_P</span></tt>)</li>
<li>ANISO-candidate weight: <img class="math" src="../../_images/math/0724b4fe96f9d17df6517387f79edcadbcc9566f.png" alt="\sqrt{2.0}"/> (see a constant <tt class="docutils literal"><span class="pre">H2DRS_DEFAULT_ERR_WEIGHT_ANISO</span></tt>)</li>
</ul>
<p>Since these weights are default, it is not necessary to express them explicitly. Nevertheless, if expressed, a particular line of the code would be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">selector</span><span class="o">.</span><span class="n">set_error_weights</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">));</span>
</pre></div>
</div>
<p>Besides the error weights, the selector allows you to modify a default behaviour through the method set_option(). The behavior can be modified anytime. Currently, the method accepts following options:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">H2D_PREFER_SYMMETRIC_MESH</span></tt>: Prefer symmetric mesh when selection of the best candidate is done. If set and if two or more candidates has the same score, they are skipped. This option is set by default.</li>
<li><tt class="docutils literal"><span class="pre">H2D_APPLY_CONV_EXP_DOF</span></tt>: Use <img class="math" src="../../_images/math/9944eede248628d1760975af2572ef77c6ec1193.png" alt="d^c - d_0^c"/>, where <img class="math" src="../../_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> is the convergence exponent, instead of <img class="math" src="../../_images/math/b8a77beebaf7fa4a30843b249cc8732412f4af4e.png" alt="(d - d_0)^c"/> to evaluate the score. This options is <em>not</em> set by default.</li>
</ul>
<p>In this case, default settings are used. If expressed explicitly, the code would be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">selector</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="n">H2D_PREFER_SYMMETRIC_MESH</span><span class="p">,</span> <span class="n">true</span><span class="p">);</span>
<span class="n">selector</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="n">H2D_APPLY_CONV_EXP_DOF</span><span class="p">,</span> <span class="n">false</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="short-version">
<h3>Short version<a class="headerlink" href="#short-version" title="Permalink to this headline">¶</a></h3>
<p>If you prefer to avoid technical details of automatic adaptivity, fill the structure
AdaptivityParamType with parameters ERR_STOP, NDOF_STOP, THRESHOLD, STRATEGY,
and MESH_REGULARITY:</p>
<div class="highlight-python"><pre>// Initialize adaptivity parameters.
AdaptivityParamType apt(ERR_STOP, NDOF_STOP, THRESHOLD, STRATEGY,
                        MESH_REGULARITY);</pre>
</div>
<p>The algorithm will stop after the relative error estimate in percent drops
below ERR_STOP or if the number of degrees of freedom exceeds NDOF_STOP.
The meaning of the other three parameters will be explained below.</p>
<p>Next, just call the function solve_linear_adapt():</p>
<div class="highlight-python"><pre>// Adaptivity loop.
Solution *sln = new Solution();
Solution *ref_sln = new Solution();
WinGeom* sln_win_geom = new WinGeom(0, 0, 400, 600);
WinGeom* mesh_win_geom = new WinGeom(410, 0, 400, 600);
bool verbose = true;     // Print info during adaptivity.
// The NULL pointer means that we do not want the resulting coefficient vector.
solve_linear_adapt(&amp;space, &amp;wf, NULL, matrix_solver, H2D_H1_NORM, sln, ref_sln,
                   sln_win_geom, mesh_win_geom, &amp;selector, &amp;apt, verbose);</pre>
</div>
<p>Here &#8216;sln&#8217; and &#8216;ref_sln&#8217; stand for solutions on the coarse and globally refined mesh,
respectively, and the WinGeom structures hold positions and geometries for visualization
of the coarse mesh solution and the mesh during adaptivity. The visualization can be
turned off by providing NULL pointers. After adaptivity is finished, the Space contains
the latest coarse mesh, and the user can request the coefficient vector by providing
a non-NULL pointer to Vector as the third argument. The latest solutions on the coarse and
globally refined meshes are in &#8216;sln&#8217; and &#8216;ref_sln&#8217;.</p>
</div>
<div class="section" id="long-version">
<h3>Long version<a class="headerlink" href="#long-version" title="Permalink to this headline">¶</a></h3>
<p>The long version of this example,
<a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/10-adapt-long">10-adapt-long</a>, exposes all
details of the adaptivity algorithm. First one needs to initialize
the matrix solver (as in example 03):</p>
<div class="highlight-python"><pre>// Initialize matrix solver.
Matrix* mat; Vector* rhs; CommonSolver* solver;
init_matrix_solver(matrix_solver, get_num_dofs(space), mat, rhs, solver);</pre>
</div>
<p>Next one can initialize views for the solution and mesh during adaptivity:</p>
<div class="highlight-python"><pre>// Initialize views.
ScalarView s_view("Solution", new WinGeom(0, 0, 400, 600));
OrderView  o_view("Mesh", new WinGeom(410, 0, 400, 600));</pre>
</div>
<p>In order to plot convergence graphs, one can use the SimpleGraph class:</p>
<div class="highlight-python"><pre>// DOF and CPU convergence graphs.
SimpleGraph graph_dof_est, graph_cpu_est;</pre>
</div>
<p>This class will save convergence data as two numbers per line: either
the number of DOF and error, or CPU time and error. A more advanced
GnuplotGraph class is also available, see the file <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/src/graph.h">graph.h</a> for more details.</p>
<p><strong>Adaptivity loop</strong></p>
<p>The adaptivity algorithm in Hermes needs a coarse mesh solution and a reference
solution on globally refined mesh. These solutions are subtracted in each adaptivity
step in order to obtain an error estimate (as a function). This function is used to
decide which elements need to be refined as well as to select optimal hp-refinement
for each element that needs to be refined. Hence the adaptivity loop begins with refining
the mesh globally and calculating the reference solution:</p>
<div class="highlight-python"><pre>// Adaptivity loop.
Solution *sln = new Solution();
Solution *ref_sln = new Solution();
int as = 1; bool done = false;
do
{
  info("---- Adaptivity step %d:", as);
  info("Solving on reference mesh.");

  // Construct globally refined reference mesh
  // and setup reference space.
  Mesh *ref_mesh = new Mesh();
  ref_mesh-&gt;copy(space-&gt;get_mesh());
  ref_mesh-&gt;refine_all_elements();
  Space* ref_space = space-&gt;dup(ref_mesh);
  int order_increase = 1;
  ref_space-&gt;copy_orders(space, order_increase);

  // Solve the reference problem.
  solve_linear(ref_space, &amp;wf, matrix_solver, ref_sln);</pre>
</div>
<p>In the next step, the reference solution is projected on the coarse
mesh in order to extract its low-order part:</p>
<div class="highlight-python"><pre>// Project the reference solution on the coarse mesh.
info("Projecting reference solution on coarse mesh.");
// NULL means that we do not want to know the resulting coefficient vector.
project_global(space, H2D_H1_NORM, ref_sln, sln, NULL);</pre>
</div>
<p>The coarse and reference mesh approximations are inserted into the class Adapt
and a global error estimate as well as element error estimates are calculated:</p>
<div class="highlight-python"><pre>// Calculate element errors.
info("Calculating error (est).");
Adapt hp(space, H2D_H1_NORM);
hp.set_solutions(sln, ref_sln);
double err_est_rel = hp.calc_elem_errors(H2D_TOTAL_ERROR_REL | H2D_ELEMENT_ERROR_REL) * 100;</pre>
</div>
<p>The error estimate is calculated as</p>
<div class="math">
<p><img src="../../_images/math/f54f7aeeaf8871752313fbf94e70ae2fbdc70a86.png" alt="e = \frac{|| u - u_{ref} ||_{H^1}}{|| u_{ref} ||_{H^1}}." /></p>
</div><p>This example uses the H1-norm but Hcurl, Hdiv and L2 norms are also possible.
If the problem is vector-valued (PDE system), arbitrary combinations are possible.
This will be discussed later.</p>
<p>Finally, if <tt class="docutils literal"><span class="pre">err_est_rel</span></tt> is still above the threshold <tt class="docutils literal"><span class="pre">ERR_STOP</span></tt>, we perform
mesh adaptation:</p>
<div class="highlight-python"><pre>// If err_est too large, adapt the mesh.
if (err_est_rel &lt; ERR_STOP) done = true;
else {
  info("Adapting the coarse mesh.");
  done = hp.adapt(&amp;selector, THRESHOLD, STRATEGY, MESH_REGULARITY);

  if (get_num_dofs(space) &gt;= NDOF_STOP) done = true;
}

// Free reference space and mesh.
ref_space-&gt;free();</pre>
</div>
<p>The constants <tt class="docutils literal"><span class="pre">THRESHOLD</span></tt>, <tt class="docutils literal"><span class="pre">STRATEGY</span></tt> and <tt class="docutils literal"><span class="pre">MESH_REGULARITY</span></tt> have the following meaning:</p>
<p>The constant <tt class="docutils literal"><span class="pre">STRATEGY</span></tt> indicates which adaptive strategy is used. In all cases, the strategy is applied to elements in an order defined through the error. If the user request to process an element outside this order, the element is processed regardless the strategy. Currently, Hermes2D supportes following strategies:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">STRATEGY</span> <span class="pre">==</span> <span class="pre">0</span></tt>: Refine elements until sqrt(<tt class="docutils literal"><span class="pre">THRESHOLD</span></tt>) times total error is processed. If more elements have similar error refine all to keep the mesh symmetric.</li>
<li><tt class="docutils literal"><span class="pre">STRATEGY</span> <span class="pre">==</span> <span class="pre">1</span></tt>: Refine all elements whose error is bigger than <tt class="docutils literal"><span class="pre">THRESHOLD</span></tt> times the error of the first processed element, i.e., the maximum error of an element.</li>
<li><tt class="docutils literal"><span class="pre">STRATEGY</span> <span class="pre">==</span> <span class="pre">2</span></tt>: Refine all elements whose error is bigger than <tt class="docutils literal"><span class="pre">THRESHOLD</span></tt>.</li>
</ul>
<p>The constant <tt class="docutils literal"><span class="pre">MESH_REGULARITY</span></tt>
specifies maximum allowed level of hanging nodes: -1 means arbitrary-level
hanging nodes (default), and 1, 2, 3, ... means 1-irregular mesh,
2-irregular mesh, etc. Hermes does not support adaptivity on regular meshes
because of its extremely poor performance.</p>
<p>It is a good idea to spend some time playing with these parameters to
get a feeling for adaptive <em>hp</em>-FEM. Also look at other adaptivity examples in
the examples/ directory: layer, lshape deal with elliptic problems and have
known exact solutions. So do examples screen, bessel for time-harmonic
Maxwell&#8217;s equations. These examples allow you to compare the error estimates
computed by Hermes with the true error. Examples crack, singpert show
how to handle cracks and singularly perturbed problems, respectively. There
are also more advanced examples illustrating automatic adaptivity for nonlinear
problems solved via the Newton&#8217;s method, adaptive multimesh <em>hp</em>-FEM,
adaptivity for time-dependent problems on dynamical meshes, etc.</p>
<p>But let&#8217;s return to the micromotor example for a moment again: The computation
starts with a very coarse mesh consisting of a few quadrilaterals, some
of which are moreover very ill-shaped. Thanks to the anisotropic refinement
capabilities of the selector, the mesh quickly adapts to the solution
and elements of reasonable shape are created near singularities, which occur
at the corners of the electrode. Initially, all elements of the mesh
are of a low degree, but as the <em>hp</em>-adaptive process progresses, the elements
receive different polynomial degrees, depending on the local smoothness of the
solution.</p>
<p>The gradient was visualized using the class VectorView. We have
seen this in the previous section. We plug in the same solution for both vector
components, but specify that its derivatives should be used:</p>
<div class="highlight-python"><pre>gview.show(&amp;sln, &amp;sln, H2D_EPS_NORMAL, H2D_FN_DX_0, H2D_FN_DY_0);</pre>
</div>
<img align="left" alt="Solution - electrostatic potential :math:`\varphi` (zoomed)." class="align-left" src="../../_images/motor-sln.png" style="width: 300px; height: 300px;" />
<img align="right" alt="Gradient of the solution :math:`E = -\nabla\varphi` and its magnitude (zoomed)." class="align-right" src="../../_images/motor-grad.png" style="width: 300px; height: 300px;" />
<hr style="clear: both; visibility: hidden;"><div align="center" class="align-center"><img alt="Polynomial orders of elements near singularities (zoomed)." class="align-center" src="../../_images/motor-orders.png" style="width: 300px; height: 300px;" /></div>
<p>Convergence graphs of adaptive h-FEM with linear elements, h-FEM with quadratic elements
and hp-FEM are shown below.</p>
<div align="center" class="align-center"><img alt="DOF convergence graph for tutorial example 10-adapt." class="align-center" src="../../_images/conv_dof11.png" style="width: 600px; height: 400px;" /></div>
<p>The following graph shows convergence in terms of CPU time.</p>
<div align="center" class="align-center"><img alt="CPU convergence graph for tutorial example 10-adapt." class="align-center" src="../../_images/conv_cpu11.png" style="width: 600px; height: 400px;" /></div>
</div>
</div>
<div class="section" id="multimesh-hp-fem">
<h2>Multimesh hp-FEM<a class="headerlink" href="#multimesh-hp-fem" title="Permalink to this headline">¶</a></h2>
<p>In multiphysics PDE systems (or just PDE systems) it can happen that one
physical field (solution component) has a singularity or a boundary layer
where other fields are smooth. If one approximates all fields on the
same mesh, then the necessity to refine the mesh at the singularity
or boundary layer implies new degrees of freedom for the smooth fields
as well. This can be very wasteful indeed, as we will see in the next
example that deals with a simplified Fitzhugh-Nagumo system. But let us
first explain briefly the main idea of the multimesh discretization
method that we developed to circumvent this problem.</p>
<p>Hermes makes it possible to approximate them
on individual meshes. These meshes are not completely independent
of each other &#8211; they have a common coarse mesh that we call <em>master mesh</em>.
The master mesh is there for algorithmic purposes only, it may not
even be used for discretization purposes: Every mesh in the system
is obtained from it via an arbitrary sequence of elementary refinements.
This is illustrated in the following figure, where (A) is the master mesh,
(B) - (D) three different meshes (say, for a coupled problem with three
equations), and (E) is the virtual <em>union mesh</em> that is used for assembling.</p>
<div align="center" class="align-center"><img alt="Multimesh" class="align-center" src="../../_images/multimesh.png" style="width: 750px;" /></div>
<p>The union mesh is not constructed physically in the computer memory &#8211;
merely it serves as a hint to correctly transform integration points
while integrating over sub-elements of the elements of the existing meshes.
The following figure shows the integration over an element <img class="math" src="../../_images/math/1d12d36ff17f66936fc1fecced3d3e2ecaca2b41.png" alt="Q_k"/> of the
virtual union mesh, and what are the appropriate subelements of the
existing elements where this integration is performed:</p>
<div align="center" class="align-center"><img alt="Multimesh" class="align-center" src="../../_images/multimesh2.png" style="width: 600px;" /></div>
<p>As a result, the multimesh discretization of the PDE system is <em>monolithic</em>
in the sense that <em>no physics is lost</em> &#8211; all integrals in the
discrete weak formulations are evaluated exactly up to the error in the
numerical quadrature. In particular, we do not perform operator splitting
or commit errors while transferring solution data between different meshes.
The multimesh assembling in Hermes works with all meshes at the same time,
there is no such thing as interpolating or projecting functions between
different meshes. More details about this method can be found in the
corresponding <a class="reference external" href="http://science.atmoshome.net/science?_ob=MImg&amp;_imagekey=B6TYH-4X1J73B-V-8Y&amp;_cdi=5619&amp;_user=10&amp;_pii=S0377042709005731&amp;_orig=browse&amp;_coverDate=08%2F18%2F2009&amp;_sk=999999999&amp;view=c&amp;wchp=dGLbVzz-zSkWz&amp;md5=6552d3390232dcffc9ca97e9bb626fb0&amp;ie=/sdarticle.pdf">research article</a>.</p>
<div class="section" id="adaptivity-in-the-multimesh-hp-fem">
<h3>Adaptivity in the Multimesh hp-FEM<a class="headerlink" href="#adaptivity-in-the-multimesh-hp-fem" title="Permalink to this headline">¶</a></h3>
<p>In principle, the adaptivity procedure for single PDE could be extended
directly to systems of PDEs. In other words, two spaces can be passed into a constructor of the class H1Adapt,
two coarse and two fine solutions can be passed into set_solutions(),
and finally, calc_error() and adapt() can be called as before. In this way, error estimates in
<img class="math" src="../../_images/math/ee500eed1910756eedebc53f0079d3aaf7a5753f.png" alt="H^1"/> norm are calculated for elements in both spaces independently and the
worst ones are refined. However, this approach is not optimal if the PDEs are
coupled, since an error caused in one solution component influences the errors
in other components and vice versa.</p>
<p>Recall that in elliptic problems the bilinear form <img class="math" src="../../_images/math/582756f2f2ea8727397157cfb8638bd8f53138e8.png" alt="a(u,v)"/> defines the energetic inner product,</p>
<div class="math">
<p><img src="../../_images/math/0ef09ed26eacaf2732c2d3ef3f792a367e2bcc53.png" alt="(u,v)_e = a(u,v)." /></p>
</div><p>The norm induced by this product,</p>
<div class="math">
<p><img src="../../_images/math/b11c9b5e64b73bf3b563750a0839aa733868630e.png" alt="||u||_e = \sqrt{(u,u)_e}," /></p>
</div><p>is called the <em>energy norm</em>. When measuring the error in the energy norm
of the entire system, one can reduce the above-mentioned difficulties dramatically.
When calculating the error on an element, the energy norm accounts
also for the error caused by other solution components.</p>
<p>It is also worth mentioning that the adaptivity algorithm does not make distinctions
between various meshes. The elements of <em>all meshes in the system</em> are put into one
single array, sorted according to their estimated errors, and then the ones with the
largest error are refined. In other words, it may happen that all elements marked for refinement
will belong just to one mesh.</p>
<p>If norms of components are substantially different, it is more beneficial to use a relative error of an element rather than an absolute error. The relative error of an element is an absolute error divided by a norm of a component. This behavior can be requested while calling the method calc_error():</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">hp</span><span class="o">.</span><span class="n">calc_error</span><span class="p">(</span><span class="n">H2D_TOTAL_ERROR_REL</span> <span class="o">|</span> <span class="n">H2D_ELEMENT_ERROR_REL</span><span class="p">)</span>
</pre></div>
</div>
<p>The input parameter of the method calc_error() is a combination that is a pair: one member of the pair has to be a constant <tt class="docutils literal"><span class="pre">`H2D_TOTAL_ERROR_*`</span></tt>, the other member has to be a constant <tt class="docutils literal"><span class="pre">`H2D_ELEMENT_ERROR_*`</span></tt>. If not specified, the default pair is <tt class="docutils literal"><span class="pre">`H2D_TOTAL_ERROR_REL</span> <span class="pre">|</span> <span class="pre">H2D_ELEMENT_ERROR_ABS`</span></tt>. Currently available contants are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">`H2D_TOTAL_ERROR_REL`</span></tt>: Returned total error will be the absolute error divided by the total norm.</li>
<li><tt class="docutils literal"><span class="pre">`H2D_TOTAL_ERROR_ABS`</span></tt>: Returned total error will be the absolute error.</li>
<li><tt class="docutils literal"><span class="pre">`H2D_TOTAL_ERROR_REL`</span></tt>: Element error which is used to select elements for refinement will be an absolute error divided by the norm of the corresponding solution component.</li>
<li><tt class="docutils literal"><span class="pre">`H2D_TOTAL_ERROR_ABS`</span></tt>: Element error which is used to select elements for refinement will be the absolute error.</li>
</ul>
</div>
</div>
<div class="section" id="simplified-fitzhugh-nagumo-system-11">
<h2>Simplified Fitzhugh-Nagumo System (11)<a class="headerlink" href="#simplified-fitzhugh-nagumo-system-11" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/11-system-adapt">11-system-adapt</a>. Long version: <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/11-system-adapt-long">11-system-adapt-long</a></p>
<p>We consider a simplified version of the Fitzhugh-Nagumo equation.
This equation is a~prominent example of activator-inhibitor systems in two-component reaction-diffusion
equations, It describes a prototype of an excitable system (e.g., a neuron) and its stationary form
is</p>
<div class="math">
<p><img src="../../_images/math/8a2d6544f01054d0a39e6a34d3af874bce8b11b2.png" alt="-d^2_u \Delta u - f(u) + \sigma v = g_1,\\
-d^2_v \Delta v - u + v = g_2." /></p>
</div><p>Here the unknowns <img class="math" src="../../_images/math/7278fc3f9ba8967a3a367ff2e12c6db9387d1094.png" alt="u, v"/> are the voltage and <img class="math" src="../../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/>-gate, respectively,
The nonlinear function</p>
<div class="math">
<p><img src="../../_images/math/9834858bca44001bd66aadd734db9786db3b526a.png" alt="f(u) = \lambda u - u^3 - \kappa" /></p>
</div><p>describes how an action potential travels through a nerve. Obviously this system is nonlinear.
In order to make it simpler for this tutorial, we replace the function <img class="math" src="../../_images/math/5ccfec49017384f64543b8648a055413c86aef62.png" alt="f(u)"/> with just <img class="math" src="../../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u"/>:</p>
<div class="math">
<p><img src="../../_images/math/aaef1b0fae5dcd5c8e8897f0d7ba9c1f7d74f341.png" alt="f(u) = u." /></p>
</div><p>Our computational domain is the square <img class="math" src="../../_images/math/cb8db917323e1e95e0532c3ba32188cb435fa88f.png" alt="(-1,1)^2"/> and we consider zero Dirichlet conditions
for both <img class="math" src="../../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u"/> and <img class="math" src="../../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/>. In order to enable fair convergence comparisons, we will use the following
functions as the exact solution:</p>
<div class="math">
<p><img src="../../_images/math/8cde0d5e0b4b538b0f07ad076177890e458679fc.png" alt="u(x,y) = \cos\left(\frac{\pi}{2}x\right) \cos\left(\frac{\pi}{2}y\right),\\
v(x,y) = \hat u(x) \hat u(y)" /></p>
</div><p>where</p>
<div class="math">
<p><img src="../../_images/math/27e6de02207855328202ff2bfa4163eed74db257.png" alt="\hat u(x) = 1 - \frac{e^{kx} + e^{-kx}}{e^k + e^{-k}}" /></p>
</div><p>is the exact solution of the one-dimensional singularly perturbed
problem</p>
<div class="math">
<p><img src="../../_images/math/e0e7f5d603294b01c7685e4e0f0e6373c9e286ba.png" alt="-u'' + k^2 u - k^2 = 0" /></p>
</div><p>in <img class="math" src="../../_images/math/65e0bc049577502741df50e34e88ae0654f438b6.png" alt="(-1,1)"/>, equipped with zero Dirichlet boundary conditions. The functions <img class="math" src="../../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u"/>
and <img class="math" src="../../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/> defined above evidently satisfy the given boundary conditions, and
they also satisfy the equation, since we inserted them into the PDE system
and calculated the source functions <img class="math" src="../../_images/math/cd46d9508b388af41f4e3d7f16ce41e6c18b8bd5.png" alt="g_1"/> and <img class="math" src="../../_images/math/a6053907b455e0ef20a366e07f007ac4fc0eb002.png" alt="g_2"/> from there. These functions
are not extremely pretty, but they are not too bad either:</p>
<div class="highlight-python"><pre>// Functions g_1 and g_2.
double g_1(double x, double y)
{
  return (-cos(M_PI*x/2.)*cos(M_PI*y/2.) + SIGMA*(1. - (exp(K*x) + exp(-K*x))/(exp(K) + exp(-K)))
         * (1. - (exp(K*y) + exp(-K*y))/(exp(K) + exp(-K))) + pow(M_PI,2.)*pow(D_u,2.)*cos(M_PI*x/2.)
         *cos(M_PI*y/2.)/2.);
}

double g_2(double x, double y)
{
  return ((1. - (exp(K*x) + exp(-K*x))/(exp(K) + exp(-K)))*(1. - (exp(K*y) + exp(-K*y))/(exp(K) + exp(-K)))
         - pow(D_v,2.)*(-(1 - (exp(K*x) + exp(-K*x))/(exp(K) + exp(-K)))*(pow(K,2.)*exp(K*y) + pow(K,2.)*exp(-K*y))/(exp(K) + exp(-K))
         - (1. - (exp(K*y) + exp(-K*y))/(exp(K) + exp(-K)))*(pow(K,2.)*exp(K*x) + pow(K,2.)*exp(-K*x))/(exp(K) + exp(-K))) -
         cos(M_PI*x/2.)*cos(M_PI*y/2.));

}</pre>
</div>
<p>The weak forms can be found in the
file <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/tutorial/11-system-adapt/forms.cpp">forms.cpp</a> and
they are registered as follows:</p>
<div class="highlight-python"><pre>// Initialize the weak formulation.
WeakForm wf(2);
wf.add_matrix_form(0, 0, callback(bilinear_form_0_0));
wf.add_matrix_form(0, 1, callback(bilinear_form_0_1));
wf.add_matrix_form(1, 0, callback(bilinear_form_1_0));
wf.add_matrix_form(1, 1, callback(bilinear_form_1_1));
wf.add_vector_form(0, linear_form_0, linear_form_0_ord);
wf.add_vector_form(1, linear_form_1, linear_form_1_ord);</pre>
</div>
<p>Beware that although each of the forms is actually symmetric, one cannot use the H2D_SYM flag as in the
elasticity equations, since it has a slightly different
meaning (see example <a class="reference external" href="http://hpfem.org/hermes/doc/src/hermes2d/tutorial-1.html#systems-of-equations-08">08-system</a>).</p>
<div class="section" id="id2">
<h3>Short version<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>For the short version it is enough to call the function solve_linear_adapt():</p>
<div class="highlight-python"><pre>// Adaptivity loop.
Solution *u_sln = new Solution();
Solution *v_sln = new Solution();
Solution *ref_u_sln = new Solution();
Solution *ref_v_sln = new Solution();
ExactSolution u_exact(&amp;u_mesh, uexact);
ExactSolution v_exact(&amp;v_mesh, vexact);
bool verbose = true;  // Print info during adaptivity.
// The NULL pointer means that we do not want the resulting coefficient vector.
solve_linear_adapt(Tuple&lt;Space *&gt;(&amp;u_space, &amp;v_space), &amp;wf, NULL, matrix_solver,
                   Tuple&lt;int&gt;(H2D_H1_NORM, H2D_H1_NORM),
                   Tuple&lt;Solution *&gt;(u_sln, v_sln),
                   Tuple&lt;Solution *&gt;(ref_u_sln, ref_v_sln),
                   Tuple&lt;WinGeom *&gt;(u_sln_win_geom, v_sln_win_geom),
                   Tuple&lt;WinGeom *&gt;(u_mesh_win_geom, v_mesh_win_geom),
                   Tuple&lt;RefinementSelectors::Selector *&gt; (&amp;selector, &amp;selector), &amp;apt,
                   verbose, Tuple&lt;ExactSolution *&gt;(&amp;u_exact, &amp;v_exact));</pre>
</div>
<p>The only differences compared to example 10 are that (a) one needs two coarse and
two reference mesh solutions, and that (b) we provide an exact solution for exact error
calculation. Note that H1-norms are used for both solution components.</p>
</div>
<div class="section" id="id3">
<h3>Long version<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>The adaptivity workflow is the same as in example 10-adapt: First we perform
global refinement of each mesh:</p>
<div class="highlight-python"><pre>// Construct globally refined reference mesh
// and setup reference space.
Mesh *u_ref_mesh = new Mesh();
u_ref_mesh-&gt;copy(u_space-&gt;get_mesh());
u_ref_mesh-&gt;refine_all_elements();
Space* u_ref_space = u_space-&gt;dup(u_ref_mesh);
int order_increase = 1;
u_ref_space-&gt;copy_orders(u_space, order_increase);
Mesh *v_ref_mesh = new Mesh();
v_ref_mesh-&gt;copy(v_space-&gt;get_mesh());
v_ref_mesh-&gt;refine_all_elements();
Space* v_ref_space = v_space-&gt;dup(v_ref_mesh);
v_ref_space-&gt;copy_orders(v_space, order_increase);</pre>
</div>
<p>Then we calculate the reference solutions:</p>
<div class="highlight-python"><pre>// Solve the reference problem.
// The NULL pointer means that we do not want the resulting coefficient vector.
solve_linear(Tuple&lt;Space *&gt;(u_ref_space, v_ref_space), &amp;wf, matrix_solver,
             Tuple&lt;Solution *&gt;(u_ref_sln, v_ref_sln), NULL);</pre>
</div>
<p>Next we project each reference solutions on the corresponding coarse mesh in order to extract
their low-order parts:</p>
<div class="highlight-python"><pre>// Project the reference solution on the coarse mesh.
info("Projecting reference solution on coarse mesh.");
// NULL means that we do not want to know the resulting coefficient vector.
project_global(Tuple&lt;Space *&gt;(u_space, v_space),
               Tuple&lt;int&gt;(H2D_H1_NORM, H2D_H1_NORM),
               Tuple&lt;MeshFunction *&gt;(u_ref_sln, v_ref_sln),
               Tuple&lt;Solution *&gt;(u_sln, v_sln), NULL);</pre>
</div>
<p>The error estimate for adaptivity is calculated as follows:</p>
<div class="highlight-python"><pre>// Calculate element errors.
info("Calculating error (est).");
Adapt hp(Tuple&lt;Space *&gt;(u_space, v_space),
         Tuple&lt;int&gt;(H2D_H1_NORM, H2D_H1_NORM));
hp.set_solutions(Tuple&lt;Solution *&gt;(u_sln, v_sln),
                 Tuple&lt;Solution *&gt;(u_ref_sln, v_ref_sln));
hp.calc_elem_errors(H2D_TOTAL_ERROR_REL | H2D_ELEMENT_ERROR_REL);

// Calculate error estimate for each solution component.
double u_err_est_abs = calc_abs_error(u_sln, u_ref_sln, H2D_H1_NORM);
double u_norm_est = calc_norm(u_ref_sln, H2D_H1_NORM);
double v_err_est_abs = calc_abs_error(v_sln, v_ref_sln, H2D_H1_NORM);
double v_norm_est = calc_norm(v_ref_sln, H2D_H1_NORM);
double err_est_abs_total = sqrt(u_err_est_abs*u_err_est_abs + v_err_est_abs*v_err_est_abs);
double norm_est_total = sqrt(u_norm_est*u_norm_est + v_norm_est*v_norm_est);
double err_est_rel_total = err_est_abs_total / norm_est_total * 100.;</pre>
</div>
<p>We also calculate exact error for each solution component:</p>
<div class="highlight-python"><pre>// Calculate exact error for each solution component.
double err_exact_abs_total = 0;
double norm_exact_total = 0;
double u_err_exact_abs = calc_abs_error(u_sln, &amp;u_exact, H2D_H1_NORM);
double u_norm_exact = calc_norm(&amp;u_exact, H2D_H1_NORM);
err_exact_abs_total += u_err_exact_abs * u_err_exact_abs;
norm_exact_total += u_norm_exact * u_norm_exact;
double v_err_exact_abs = calc_abs_error(v_sln, &amp;v_exact, H2D_H1_NORM);
double v_norm_exact = calc_norm(&amp;v_exact, H2D_H1_NORM);
err_exact_abs_total += v_err_exact_abs * v_err_exact_abs;
norm_exact_total += v_norm_exact * v_norm_exact;
err_exact_abs_total = sqrt(err_exact_abs_total);
norm_exact_total = sqrt(norm_exact_total);
double err_exact_rel_total = err_exact_abs_total / norm_exact_total * 100.;</pre>
</div>
<p>The mesh adaptation step comes last, if the error estimate exceeds the
allowed tolerance ERR_STOP:</p>
<div class="highlight-python"><pre>// If err_est too large, adapt the mesh.
if (err_est_rel_total &lt; ERR_STOP) done = true;
else {
  info("Adapting the coarse mesh.");
  done = hp.adapt(Tuple&lt;RefinementSelectors::Selector *&gt;(&amp;selector, &amp;selector),
                  THRESHOLD, STRATEGY, MESH_REGULARITY);

  if (get_num_dofs(Tuple&lt;Space *&gt;(u_space, v_space)) &gt;= NDOF_STOP) done = true;
}

// Free reference meshes and spaces.
u_ref_space-&gt;free();
v_ref_space-&gt;free();

as++;</pre>
</div>
<p>The following two figures show the solutions <img class="math" src="../../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u"/> and <img class="math" src="../../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/>. Notice their
large qualitative differences: While <img class="math" src="../../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u"/> is smooth in the entire domain,
<img class="math" src="../../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/> has a thin boundary layer along the boundary:</p>
<div align="center" class="align-center"><img alt="Solution" class="align-center" src="../../_images/solution_u.png" style="width: 465px; height: 400px;" /></div>
<div align="center" class="align-center"><img alt="Solution" class="align-center" src="../../_images/solution_v.png" style="width: 465px; height: 400px;" /></div>
<p>Resulting mesh for <img class="math" src="../../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u"/> and <img class="math" src="../../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/> obtained using conventional (single-mesh) hp-FEM: 12026 DOF
(6013 for each solution).</p>
<div align="center" class="align-center"><img alt="Mesh" class="align-center" src="../../_images/mesh_single.png" style="width: 465px; height: 400px;" /></div>
<p>Resulting mesh for <img class="math" src="../../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u"/> obtained using the multimesh hp-FEM: 169 DOF</p>
<div align="center" class="align-center"><img alt="Mesh" class="align-center" src="../../_images/mesh_multi_u.png" style="width: 465px; height: 400px;" /></div>
<p>Resulting mesh for <img class="math" src="../../_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/> obtained using the multimesh hp-FEM: 3565 DOF</p>
<div align="center" class="align-center"><img alt="Mesh" class="align-center" src="../../_images/mesh_multi_v.png" style="width: 465px; height: 400px;" /></div>
<p>DOF convergence graphs:</p>
<div align="center" class="align-center"><img alt="DOF convergence graph." class="align-center" src="../../_images/conv_dof12.png" style="width: 600px; height: 400px;" /></div>
<p>CPU time convergence graphs:</p>
<div align="center" class="align-center"><img alt="CPU convergence graph." class="align-center" src="../../_images/conv_cpu12.png" style="width: 600px; height: 400px;" /></div>
</div>
</div>
<div class="section" id="adaptivity-for-general-2nd-order-linear-equation-12">
<h2>Adaptivity for General 2nd-Order Linear Equation (12)<a class="headerlink" href="#adaptivity-for-general-2nd-order-linear-equation-12" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/12-general-adapt">12-general-adapt</a>. Long version: <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/12-general-adapt-long">12-general-adapt-long</a>.</p>
<p>This example does not bring anything substantially new and its purpose is solely to
save you work adding adaptivity to the tutorial example
<a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/07-general">07-general</a>.
Feel free to adjust this example for your own applications.</p>
<p>Solution:</p>
<div align="center" class="align-center"><img alt="Solution to the general 2nd-order linear equation example." class="align-center" src="../../_images/12-solution.png" style="width: 465px; height: 400px;" /></div>
<p>Final hp-mesh:</p>
<div align="center" class="align-center"><img alt="Final finite element mesh for the general 2nd-order linear equation example." class="align-center" src="../../_images/12-mesh.png" style="width: 450px; height: 400px;" /></div>
<p>Convergence graphs of adaptive h-FEM with linear elements, h-FEM with quadratic elements
and hp-FEM.</p>
<div align="center" class="align-center"><img alt="DOF convergence graph for tutorial example 12-general-adapt." class="align-center" src="../../_images/conv_dof13.png" style="width: 600px; height: 400px;" /></div>
<p>Convergence comparison in terms of CPU time.</p>
<div align="center" class="align-center"><img alt="CPU convergence graph for tutorial example 12-general-adapt." class="align-center" src="../../_images/conv_cpu13.png" style="width: 600px; height: 400px;" /></div>
</div>
<div class="section" id="complex-valued-problem-13">
<h2>Complex-Valued Problem (13)<a class="headerlink" href="#complex-valued-problem-13" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/13-complex-adapt">13-complex-adapt</a>. Long version: <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/13-complex-adapt-long">13-complex-adapt-long</a>.</p>
<p>This example solves a complex-valued vector potential problem</p>
<div class="math">
<p><img src="../../_images/math/87605b09ed3429f8f621dd94e821cef998704e40.png" alt="-\Delta A + j \omega \gamma \mu A = \mu J_{ext}" /></p>
</div><p>in a two-dimensional cross-section containing a conductor and an iron object as
shown in the following schematic picture:</p>
<div align="center" class="align-center"><img alt="Domain." class="align-center" src="../../_images/domain5.png" style="height: 500px;" /></div>
<p>The computational domain is a rectangle of height 0.003 and width 0.004.
Different material markers are used for the wire, air, and iron
(see mesh file <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/tutorial/13-complex-adapt/domain2.mesh">domain2.mesh</a>).</p>
<p>Boundary conditions are zero Dirichlet on the top and right edges, and zero Neumann
elsewhere.</p>
<p>Solution:</p>
<div align="center" class="align-center"><img alt="Solution." class="align-center" src="../../_images/solution4.png" style="height: 400px;" /></div>
<p>Complex-valued weak forms:</p>
<div class="highlight-python"><pre>template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form_iron(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  scalar ii = cplx(0.0, 1.0);
  return 1./mu_iron * int_grad_u_grad_v&lt;Real, Scalar&gt;(n, wt, u, v) + ii*omega*gamma_iron*int_u_v&lt;Real, Scalar&gt;(n, wt, u, v);
}

template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form_wire(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return 1./mu_0 * int_grad_u_grad_v&lt;Real, Scalar&gt;(n, wt, u, v);
}

template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form_air(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return 1./mu_0 * int_grad_u_grad_v&lt;Real, Scalar&gt;(n, wt, u, v); // conductivity gamma is zero
}

template&lt;typename Real, typename Scalar&gt;
Scalar linear_form_wire(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  return J_wire * int_v&lt;Real, Scalar&gt;(n, wt, v);
}</pre>
</div>
<p>After loading the mesh and performing initial mesh refinements, we create an H1 space:</p>
<div class="highlight-python"><pre>// Create an H1 space with default shapeset.
H1Space space(&amp;mesh, bc_types, essential_bc_values, P_INIT);</pre>
</div>
<p>The weak forms are registered as follows:</p>
<div class="highlight-python"><pre>// Initialize the weak formulation.
WeakForm wf;
wf.add_matrix_form(callback(bilinear_form_iron), H2D_SYM, 3);
wf.add_matrix_form(callback(bilinear_form_wire), H2D_SYM, 2);
wf.add_matrix_form(callback(bilinear_form_air), H2D_SYM, 1);
wf.add_vector_form(callback(linear_form_wire), 2);</pre>
</div>
<div class="section" id="id4">
<h3>Short version<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>The only thing worth noticing here is that a Boolean variable
&#8216;is_complex = true&#8217; is passed into the function solve_linear_adapt():</p>
<div class="highlight-python"><pre>// Adaptivity loop.
Solution *sln = new Solution();
Solution *ref_sln = new Solution();
WinGeom* sln_win_geom = new WinGeom(0, 0, 600, 350);
WinGeom* mesh_win_geom = new WinGeom(610, 0, 520, 350);
bool verbose = true;     // Print info during adaptivity.
bool is_complex = true;
// The NULL pointer means that we do not want the resulting coefficient vector.
solve_linear_adapt(&amp;space, &amp;wf, NULL, matrix_solver, H2D_H1_NORM, sln, ref_sln,
                   sln_win_geom, mesh_win_geom, &amp;selector, &amp;apt, verbose,
                   Tuple&lt;ExactSolution *&gt;(), is_complex);</pre>
</div>
</div>
<div class="section" id="id5">
<h3>Long version<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>In the long version, the variable &#8216;is_complex&#8217; is used at several places.
First during the matrix initialization:</p>
<div class="highlight-python"><pre>// Initialize matrix solver.
bool is_complex = true;
Matrix* mat; Vector* rhs; CommonSolver* solver;
init_matrix_solver(matrix_solver, get_num_dofs(space), mat, rhs, solver, is_complex);</pre>
</div>
<p>Then in the solution of the linear problem on the globally refined reference mesh:</p>
<div class="highlight-python"><pre>// Solve the reference problem.
// The NULL pointer means that we do not want the resulting coefficient vector.
solve_linear(ref_space, &amp;wf, matrix_solver, ref_sln, NULL, is_complex);</pre>
</div>
<p>And finally in the global projection on the coarse mesh:</p>
<div class="highlight-python"><pre>// Project the reference solution on the coarse mesh.
info("Projecting reference solution on coarse mesh.");
// NULL means that we do not want to know the resulting coefficient vector.
project_global(space, H2D_H1_NORM, ref_sln, sln, NULL, is_complex);</pre>
</div>
<p>Otherwise everything is the same as in example 10.</p>
<p>Let us compare adaptive <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/>-FEM with linear and quadratic elements and the <img class="math" src="../../_images/math/e158fefb7519a21c5a175711642a9c9295ef314f.png" alt="hp"/>-FEM.</p>
<p>Final mesh for <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/>-FEM with linear elements: 18694 DOF, error = 1.02 %</p>
<div align="center" class="align-center"><img alt="Mesh." class="align-center" src="../../_images/mesh-h16.png" style="height: 400px;" /></div>
<p>Final mesh for <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/>-FEM with quadratic elements: 46038 DOF, error = 0.018 %</p>
<div align="center" class="align-center"><img alt="Mesh." class="align-center" src="../../_images/mesh-h26.png" style="height: 400px;" /></div>
<p>Final mesh for <img class="math" src="../../_images/math/e158fefb7519a21c5a175711642a9c9295ef314f.png" alt="hp"/>-FEM: 4787 DOF, error = 0.00918 %</p>
<div align="center" class="align-center"><img alt="Mesh." class="align-center" src="../../_images/mesh-hp6.png" style="height: 400px;" /></div>
<p>Convergence graphs of adaptive h-FEM with linear elements, h-FEM with quadratic elements
and hp-FEM are shown below.</p>
<div align="center" class="align-center"><img alt="DOF convergence graph." class="align-center" src="../../_images/conv_compar_dof3.png" style="width: 600px; height: 400px;" /></div>
</div>
</div>
<div class="section" id="time-harmonic-maxwell-s-equations-14">
<h2>Time-Harmonic Maxwell&#8217;s Equations (14)<a class="headerlink" href="#time-harmonic-maxwell-s-equations-14" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/14-hcurl-adapt">14-hcurl-adapt</a>. Long version: <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/14-hcurl-adapt-long">14-hcurl-adapt-long</a>.</p>
<p>This example solves the time-harmonic Maxwell&#8217;s equations in an L-shaped domain and it
describes the diffraction of an electromagnetic wave from a re-entrant corner. It comes with an
exact solution that contains a strong singularity.</p>
<p>Equation solved: Time-harmonic Maxwell&#8217;s equations</p>
<div class="math" id="equation-example-14">
<p><span class="eqno">(1)</span><img src="../../_images/math/559fb5420cb5e77f07134493136c0b8c3d56468d.png" alt="\frac{1}{\mu_r} \nabla \times \nabla \times E - \kappa^2 \epsilon_r E = \Phi." /></p>
</div><p>Domain of interest is the square <img class="math" src="../../_images/math/bc2b2a54f46c6bede1845ab7359db315483e275b.png" alt="(-10, 10)^2"/> missing the quarter lying in the
fourth quadrant. It is filled with air:</p>
<div align="center" class="align-center"><img alt="Computational domain." class="align-center" src="../../_images/domain6.png" style="width: 490px; height: 490px;" /></div>
<p>Boundary conditions: Combined essential and natural, see the
<a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/tutorial/14-hcurl-adapt/main.cpp">main.cpp</a> file.</p>
<p>Exact solution:</p>
<div class="math" id="equation-example-14-exact">
<p><span class="eqno">(2)</span><img src="../../_images/math/fb08c3ba9f32f6963407aa2bdf18facfd9640743.png" alt="E(x, y) = \nabla \times J_{\alpha} (r) \cos(\alpha \theta)" /></p>
</div><p>where <img class="math" src="../../_images/math/7886174f5bec2883392571c6f8b9cfb2d0065222.png" alt="J_{\alpha}"/> is the Bessel function of the first kind,
<img class="math" src="../../_images/math/e31f416f2b44eebe61679d8344cf8bf35feb1f73.png" alt="(r, \theta)"/> the polar coordinates and <img class="math" src="../../_images/math/b0a311c15467f67137df4476c31dcaec3601d184.png" alt="\alpha = 2/3"/>. In
computer code, this reads:</p>
<div class="highlight-python"><pre>void exact_sol(double x, double y, scalar&amp; e0, scalar&amp; e1)
{
  double t1 = x*x;
  double t2 = y*y;
  double t4 = sqrt(t1+t2);
  double t5 = jv(-1.0/3.0,t4);
  double t6 = 1/t4;
  double t7 = jv(2.0/3.0,t4);
  double t11 = (t5-2.0/3.0*t6*t7)*t6;
  double t12 = atan2(y,x);
  if (t12 &lt; 0) t12 += 2.0*M_PI;
  double t13 = 2.0/3.0*t12;
  double t14 = cos(t13);
  double t17 = sin(t13);
  double t18 = t7*t17;
  double t20 = 1/t1;
  double t23 = 1/(1.0+t2*t20);
  e0 = t11*y*t14-2.0/3.0*t18/x*t23;
  e1 = -t11*x*t14-2.0/3.0*t18*y*t20*t23;
}</pre>
</div>
<p>Here jv() is the Bessel function <img class="math" src="../../_images/math/0c6fbcc402bba2381be191dd83dd7cbeffdc8ca0.png" alt="\bfJ_{\alpha}"/>. For its source code see the
<a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/tutorial/14-hcurl-adapt/forms.cpp">forms.cpp</a> file.</p>
<p>New in this example is the fact that we solve in the Hcurl space:</p>
<div class="highlight-python"><pre>// Create an Hcurl space with default shapeset.
HcurlSpace space(&amp;mesh, bc_types, essential_bc_values, P_INIT);</pre>
</div>
<p>Also the refinement selector is for the Hcurl space:</p>
<div class="highlight-python"><pre>// Initialize refinement selector.
HcurlProjBasedSelector selector(CAND_LIST, CONV_EXP, H2DRS_DEFAULT_ORDER);</pre>
</div>
<div class="section" id="id7">
<h3>Short version<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>In the short version we need to use the H2D_HCURL_NORM:</p>
<div class="highlight-python"><pre>// Adaptivity loop.
Solution *sln = new Solution();
Solution *ref_sln = new Solution();
ExactSolution exact_sln(&amp;mesh, exact);
WinGeom* sln_win_geom = new WinGeom(0, 0, 440, 350);
WinGeom* mesh_win_geom = new WinGeom(450, 0, 400, 350);
bool verbose = true;     // Print info during adaptivity.
bool is_complex = true;
// The NULL pointer means that we do not want the resulting coefficient vector.
solve_linear_adapt(&amp;space, &amp;wf, NULL, matrix_solver, H2D_HCURL_NORM, sln, ref_sln,
                   sln_win_geom, mesh_win_geom, &amp;selector, &amp;apt, verbose, &amp;exact_sln, is_complex);</pre>
</div>
</div>
<div class="section" id="id8">
<h3>Long version<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>In the long version it is worth noticing that H2D_HCURL_NORM is used in the
global projection</p>
<div class="highlight-python"><pre>// Project the reference solution on the coarse mesh.
info("Projecting reference solution on coarse mesh.");
// NULL means that we do not want to know the resulting coefficient vector.
project_global(space, H2D_HCURL_NORM, ref_sln, sln, NULL, is_complex);</pre>
</div>
<p>as well as in the initialization of the Adapt class:</p>
<div class="highlight-python"><pre>// Calculate element errors.
info("Calculating error (est).");
Adapt hp(space, H2D_HCURL_NORM);
hp.set_solutions(sln, ref_sln);
double err_est_rel = hp.calc_elem_errors(H2D_TOTAL_ERROR_REL | H2D_ELEMENT_ERROR_REL) * 100.;</pre>
</div>
<p>The code for the weak forms looks as follows:</p>
<div class="highlight-python"><pre>template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
return 1.0/mu_r * int_curl_e_curl_f&lt;Real, Scalar&gt;(n, wt, u, v) -
       sqr(kappa) * int_e_f&lt;Real, Scalar&gt;(n, wt, u, v);
}

template&lt;typename Real, typename Scalar&gt;
Scalar bilinear_form_surf(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  cplx ii = cplx(0.0, 1.0);
  return ii * (-kappa) * int_e_tau_f_tau&lt;Real, Scalar&gt;(n, wt, u, v, e);
}

scalar linear_form_surf(int n, double *wt, Func&lt;scalar&gt; *u_ext[], Func&lt;double&gt; *v, Geom&lt;double&gt; *e, ExtData&lt;scalar&gt; *ext)
{
  scalar result = 0;
  for (int i = 0; i &lt; n; i++)
  {
    double r = sqrt(e-&gt;x[i] * e-&gt;x[i] + e-&gt;y[i] * e-&gt;y[i]);
    double theta = atan2(e-&gt;y[i], e-&gt;x[i]);
    if (theta &lt; 0) theta += 2.0*M_PI;
    double j13    = jv(-1.0/3.0, r),    j23    = jv(+2.0/3.0, r);
    double cost   = cos(theta),         sint   = sin(theta);
    double cos23t = cos(2.0/3.0*theta), sin23t = sin(2.0/3.0*theta);

    double Etau = e-&gt;tx[i] * (cos23t*sint*j13 - 2.0/(3.0*r)*j23*(cos23t*sint + sin23t*cost)) +
                  e-&gt;ty[i] * (-cos23t*cost*j13 + 2.0/(3.0*r)*j23*(cos23t*cost - sin23t*sint));

    result += wt[i] * cplx(cos23t*j23, -Etau) * ((v-&gt;val0[i] * e-&gt;tx[i] + v-&gt;val1[i] * e-&gt;ty[i]));
  }
  return result;
}

// Maximal polynomial order to integrate surface linear form.
Ord linear_form_surf_ord(int n, double *wt, Func&lt;Ord&gt; *u_ext[], Func&lt;Ord&gt; *v, Geom&lt;Ord&gt; *e, ExtData&lt;Ord&gt; *ext)
{  return Ord(v-&gt;val[0].get_max_order());  }</pre>
</div>
<p>Solution:</p>
<div align="center" class="align-center"><img alt="Solution." class="align-center" src="../../_images/solution5.png" style="width: 500px; height: 420px;" /></div>
<p>Final mesh (h-FEM with linear elements):</p>
<div align="center" class="align-center"><img alt="Final mesh (h-FEM with linear elements)." class="align-center" src="../../_images/mesh-h17.png" style="width: 460px; height: 390px;" /></div>
<p>Note that the polynomial order indicated corresponds to the tangential components
of approximation on element interfaces, not to polynomial degrees inside the elements
(those are one higher).</p>
<p>Final mesh (h-FEM with quadratic elements):</p>
<div align="center" class="align-center"><img alt="Final mesh (h-FEM with quadratic elements)." class="align-center" src="../../_images/mesh-h27.png" style="width: 460px; height: 390px;" /></div>
<p>Final mesh (hp-FEM):</p>
<div align="center" class="align-center"><img alt="Final mesh (hp-FEM)." class="align-center" src="../../_images/mesh-hp7.png" style="width: 460px; height: 390px;" /></div>
<p>DOF convergence graphs:</p>
<div align="center" class="align-center"><img alt="DOF convergence graph." class="align-center" src="../../_images/conv_dof14.png" style="width: 600px; height: 400px;" /></div>
<p>CPU time convergence graphs:</p>
<div align="center" class="align-center"><img alt="CPU convergence graph." class="align-center" src="../../_images/conv_cpu14.png" style="width: 600px; height: 400px;" /></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">Hermes2D Tutorial: Part II (Automatic Adaptivity)</a><ul>
<li><a class="reference external" href="#adaptive-h-fem-and-hp-fem">Adaptive h-FEM and hp-FEM</a><ul>
<li><a class="reference external" href="#large-number-of-possible-element-refinements-in-hp-fem">Large number of possible element refinements in &#8216;hp&#8217;-FEM</a></li>
</ul>
</li>
<li><a class="reference external" href="#understanding-convergence-rates">Understanding Convergence Rates</a><ul>
<li><a class="reference external" href="#algebraic-convergence-of-adaptive-fem">Algebraic convergence of adaptive <img class="math" src="../../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/>-FEM</a></li>
<li><a class="reference external" href="#exponential-convergence-of-adaptive-fem">Exponential convergence of adaptive <img class="math" src="../../_images/math/e158fefb7519a21c5a175711642a9c9295ef314f.png" alt="hp"/>-FEM</a></li>
<li><a class="reference external" href="#estimated-vs-exact-convergence-rates">Estimated vs. exact convergence rates</a></li>
</ul>
</li>
<li><a class="reference external" href="#electrostatic-micromotor-problem-10">Electrostatic Micromotor Problem (10)</a><ul>
<li><a class="reference external" href="#refinement-selector">Refinement selector</a></li>
<li><a class="reference external" href="#short-version">Short version</a></li>
<li><a class="reference external" href="#long-version">Long version</a></li>
</ul>
</li>
<li><a class="reference external" href="#multimesh-hp-fem">Multimesh hp-FEM</a><ul>
<li><a class="reference external" href="#adaptivity-in-the-multimesh-hp-fem">Adaptivity in the Multimesh hp-FEM</a></li>
</ul>
</li>
<li><a class="reference external" href="#simplified-fitzhugh-nagumo-system-11">Simplified Fitzhugh-Nagumo System (11)</a><ul>
<li><a class="reference external" href="#id2">Short version</a></li>
<li><a class="reference external" href="#id3">Long version</a></li>
</ul>
</li>
<li><a class="reference external" href="#adaptivity-for-general-2nd-order-linear-equation-12">Adaptivity for General 2nd-Order Linear Equation (12)</a></li>
<li><a class="reference external" href="#complex-valued-problem-13">Complex-Valued Problem (13)</a><ul>
<li><a class="reference external" href="#id4">Short version</a></li>
<li><a class="reference external" href="#id5">Long version</a></li>
</ul>
</li>
<li><a class="reference external" href="#time-harmonic-maxwell-s-equations-14">Time-Harmonic Maxwell&#8217;s Equations (14)</a><ul>
<li><a class="reference external" href="#id7">Short version</a></li>
<li><a class="reference external" href="#id8">Long version</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="tutorial-1.html"
                                  title="previous chapter">Hermes2D Tutorial: Part I (Linear Problems)</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="tutorial-3.html"
                                  title="next chapter">Hermes2D Tutorial: Part III (Nonlinear Problems)</a></p>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial-3.html" title="Hermes2D Tutorial: Part III (Nonlinear Problems)"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial-1.html" title="Hermes2D Tutorial: Part I (Linear Problems)"
             >previous</a> |</li>
        <li><a href="../../index.html">Content</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, hp-FEM group at UNR.
      Last updated on Nov 11, 2010.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  </body>
</html>