<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Hermes2D Tutorial: Part III (Nonlinear Problems) &mdash; Hermes2D Documentation</title>
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Hermes2D Documentation" href="../../index.html" />
    <link rel="next" title="Hermes2D Tutorial: Part IV (Adaptivity for Time-Dependent Problems)" href="tutorial-4.html" />
    <link rel="prev" title="Hermes2D Tutorial: Part II (Automatic Adaptivity)" href="tutorial-2.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial-4.html" title="Hermes2D Tutorial: Part IV (Adaptivity for Time-Dependent Problems)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial-2.html" title="Hermes2D Tutorial: Part II (Automatic Adaptivity)"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">Content</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="hermes2d-tutorial-part-iii-nonlinear-problems">
<h1>Hermes2D Tutorial: Part III (Nonlinear Problems)<a class="headerlink" href="#hermes2d-tutorial-part-iii-nonlinear-problems" title="Permalink to this headline">¶</a></h1>
<p>This part of the tutorial assumes that the reader is familiar with the solution of
linear problems (Part I). We will begin with explaining the basics of the Newton&#8217;s
method for nonlinear PDE problems, and then illustrate it on examples with gradually
increasing complexity. At the end of Part III the reader will be able to solve time-dependent
nonlinear multiphysics PDE systems.</p>
<div class="section" id="the-newton-s-method">
<h2>The Newton&#8217;s Method<a class="headerlink" href="#the-newton-s-method" title="Permalink to this headline">¶</a></h2>
<p>Consider a simple model problem of the form</p>
<div class="math" id="equation-newton0">
<p><span class="eqno">(1)</span><img src="../../_images/math/66aafdca97f2fe0d562d5a8d7313ba98efbba0f5.png" alt="-\nabla \cdot (\lambda(u)\nabla u) - f(\bfx) = 0, \ \ \ u = 0 \ \mbox{on}\ \partial \Omega." /></p>
</div><p>Note that when using the Newton&#8217;s method, it is customary to have
everything on the left-hand side. The corresponding discrete problem has the form</p>
<div class="math">
<p><img src="../../_images/math/54cf726dd4ac676587ae1cbea8dd65e302a22d3f.png" alt="\int_{\Omega} \lambda(u)\nabla u(\bfx) \cdot \nabla v_i(\bfx)\, \mbox{d}\bfx
- \int_{\Omega} f(\bfx)v_i(\bfx) \, \mbox{d}\bfx\ \ \ \mbox{for all} \ i = 1, 2, \ldots, N," /></p>
</div><p>where <img class="math" src="../../_images/math/85ffd98b4eaea58a8db38fd0047e3a1d7c5661a0.png" alt="v_i"/> are the standard test functions and</p>
<div class="math">
<p><img src="../../_images/math/fd205184b9b89fc8e7bcfc54ebd49177b7ac9574.png" alt="u(\bfY) = \sum_{j=1}^N y_j v_j." /></p>
</div><p>Here <img class="math" src="../../_images/math/43d56562c98f9ce4d89b58be1437fa512df21c33.png" alt="\bfY = (y_1, y_2, \ldots, y_N)^T"/> is the vector of unknown coefficients.
The nonlinear discrete problem can be written in the compact form</p>
<div class="math">
<p><img src="../../_images/math/683f3985423adf9ed0ac9e9d157744f81e661042.png" alt="\bfF(\bfY) = {\bf 0}," /></p>
</div><p>where <img class="math" src="../../_images/math/aa315a920cc6146c14770d38f5aaac2642ad2a19.png" alt="\bfF = (F_1, F_2, \ldots, F_N)^T"/> is the residual vector defined by</p>
<div class="math">
<p><img src="../../_images/math/0f4d24c3860a2e059cdf24e31a95e0af5c01392f.png" alt="F_i(\bfY) =  \int_{\Omega} \lambda(u)\nabla u \cdot \nabla v_i
- f v_i \, \mbox{d}\bfx." /></p>
</div><p>The Jacobi matrix <img class="math" src="../../_images/math/c855c8b90384eadb666afd857bda09df5497255c.png" alt="\bfJ(\bfY) = D\bfF/D\bfY"/> has the same sparsity structure as the
standard stiffness matrix that we know from linear problems. In fact, when the
problem is linear then the Jacobi matrix and the stiffness matrix are the same
thing. Using the chain rule of differentiation, we calculate that on the
position <img class="math" src="../../_images/math/c26aadb390865e9669bcb79c4e6af904a2dea7cc.png" alt="ij"/>, the Jacobi matrix has the value</p>
<div class="math">
<p><img src="../../_images/math/8767a61200a76837f56541349d917543edea7614.png" alt="J_{ij}(\bfY) =  \frac{\partial F_i}{\partial y_j} =
\int_{\Omega} \left[ \frac{\partial \lambda}{\partial u} \frac{\partial u}{\partial y_j}
\nabla u + \lambda(u)\frac{\partial \nabla u}{\partial y_j} \right] \cdot \nabla v_i \, \mbox{d}\bfx." /></p>
</div><p>To this end, note that</p>
<div class="math">
<p><img src="../../_images/math/33d6a305dff3ecd91db489f1d78943cd4b947732.png" alt="\frac{\partial u}{\partial y_k} = \frac{\partial}{\partial y_k}\sum_{j=1}^N y_j v_j = v_k" /></p>
</div><p>and</p>
<div class="math">
<p><img src="../../_images/math/bfa6d0349756b4c93943f7467158b3c34b994e28.png" alt="\frac{\partial \nabla u}{\partial y_k} = \frac{\partial}{\partial y_k}\sum_{j=1}^N y_j \nabla v_j = \nabla v_k." /></p>
</div><p>Using these relations, we obtain</p>
<div class="math">
<p><img src="../../_images/math/2d99d1b3c7d22943251069fc812a385e3fc11831.png" alt="J_{ij}(\bfY) =
\int_{\Omega} \left[ \frac{\partial \lambda}{\partial u}(u) v_j
\nabla u + \lambda(u)\nabla v_j \right] \cdot \nabla v_i \, \mbox{d}\bfx." /></p>
</div><p>Let&#8217;s assume that the Jacobi matrix has been assembled.
The Newton&#8217;s method is written formally as</p>
<div class="math">
<p><img src="../../_images/math/2bcccc1ea1e77889e555496672a534b0a31e0f6f.png" alt="\bfY_{\!\!n+1} = \bfY_{\!\!n} - \bfJ^{-1}(\bfY_{\!\!n}) \bfF(\bfY_{\!\!n})," /></p>
</div><p>but a more practical formula to work with is</p>
<div class="math">
<p><img src="../../_images/math/2bc38d29b0976303cc54d0fcb989e0b1572613e7.png" alt="\bfJ(\bfY_{\!\!n})\delta \bfY_{\!\!n+1} =  - \bfF(\bfY_{\!\!n})." /></p>
</div><p>This is a system of linear algebraic equations that needs to be solved in every Newton&#8217;s
iteration. The Newton&#8217;s method will stop when <img class="math" src="../../_images/math/1f0d3f3731905b8f7f542128633c3cff010fe19b.png" alt="\bfF(\bfY_{\!\!n+1})"/> is sufficiently close
to the zero vector.</p>
<div class="section" id="a-remark-on-the-linear-case">
<h3>A remark on the linear case<a class="headerlink" href="#a-remark-on-the-linear-case" title="Permalink to this headline">¶</a></h3>
<p>In the linear case we have</p>
<div class="math">
<p><img src="../../_images/math/7b706f0a3e55d31e3bc928b2f1c85d47a77c1be9.png" alt="\bfF(\bfY) = \bfJ(\bfY)\bfY - \bfb," /></p>
</div><p>where <img class="math" src="../../_images/math/0ce007b4fc52fdd2720bb74bb7a2e8e1da1150b7.png" alt="\bfS = \bfJ(\bfY)"/> is a constant stiffness matrix and <img class="math" src="../../_images/math/16c3e53d37ba13f6b6c7e9792d8cd6eaa8652096.png" alt="\bfb"/> a load vector.
The Newton&#8217;s method is now</p>
<div class="math">
<p><img src="../../_images/math/11114cbf278eb93241e5bf95a1a40f5c576ab7e2.png" alt="\bfS\bfY_{\!\!n+1} = \bfJ(\bfY_{\!\!n})\bfY_{\!\!n}
- \bfJ(\bfY_{\!\!n})\bfY_{\!\!n} + \bfb = \bfb." /></p>
</div><p>Therefore, the Newton&#8217;s method will converge in one iteration.</p>
</div>
</div>
<div class="section" id="constant-initial-condition-15">
<h2>Constant Initial Condition (15)<a class="headerlink" href="#constant-initial-condition-15" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/15-newton-elliptic-1">15-newton-elliptic-1</a>.</p>
<p>Let us solve the nonlinear model problem from the previous section,</p>
<div class="math">
<p><img src="../../_images/math/5e499d35bc3c3d6933fa5b1a582c3af01b4e5206.png" alt="-\nabla \cdot (\lambda(u)\nabla u) - f(x,y) = 0, \ \ \ u = 0 \ \mbox{on}\ \partial \Omega." /></p>
</div><p>One possible interpretation of this equation is stationary heat transfer where the thermal
conductivity <img class="math" src="../../_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> depends on the temperature <img class="math" src="../../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u"/>.
Our domain is a square <img class="math" src="../../_images/math/a685e9c137558280fe18d9352694f5338136974d.png" alt="\Omega = (-10,10)^2"/>, <img class="math" src="../../_images/math/023077c1242e813bd67455e3d0accb0bb0032065.png" alt="f(x,y) = 1"/>, and the nonlinearity <img class="math" src="../../_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> has the form</p>
<div class="math">
<p><img src="../../_images/math/22e813294ceb1b8c345c81ec21e8813e69423035.png" alt="\lambda(u) = 1 + u^\alpha." /></p>
</div><p>Recall that <img class="math" src="../../_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> must be entirely positive or entirely negative for the problem to be solvable, so it is safe
to restrict <img class="math" src="../../_images/math/10f32377ac67d94f764f12a15ea987e88c85d3e1.png" alt="\alpha"/> to be an even nonnegative integer. Recall from the previous section that</p>
<div class="math">
<p><img src="../../_images/math/2ea1a79cbd2df18552abf26db3245532eecfa84d.png" alt="F_i(\bfY) =  \int_{\Omega} \lambda(u)\nabla u \cdot \nabla v_i
- f v_i \, \mbox{d}x\mbox{d}y." /></p>
</div><p>and</p>
<div class="math">
<p><img src="../../_images/math/9eab66d08f7da77a305addcf8bc39c348aee9f44.png" alt="J_{ij}(\bfY) =
\int_{\Omega} \left[ \frac{\partial \lambda}{\partial u}(u) v_j
\nabla u + \lambda(u)\nabla v_j \right] \cdot \nabla v_i \, \mbox{d}x\mbox{d}y." /></p>
</div><p>In the code, this becomes</p>
<div class="highlight-python"><pre>// Heat sources (can be a general function of 'x' and 'y').
template&lt;typename Real&gt;
Real heat_src(Real x, Real y)
{
  return 1.0;
}

// Jacobian matrix.
template&lt;typename Real, typename Scalar&gt;
Scalar jac(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  Scalar result = 0;
  Func&lt;Scalar&gt;* u_prev = ext-&gt;fn[0];
  for (int i = 0; i &lt; n; i++)
    result += wt[i] * (dlam_du(u_prev-&gt;val[i]) * u-&gt;val[i] * (u_prev-&gt;dx[i] * v-&gt;dx[i] + u_prev-&gt;dy[i] * v-&gt;dy[i])
                       + lam(u_prev-&gt;val[i]) * (u-&gt;dx[i] * v-&gt;dx[i] + u-&gt;dy[i] * v-&gt;dy[i]));

  return result;
}

// Residual vector.
template&lt;typename Real, typename Scalar&gt;
Scalar res(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  Scalar result = 0;
  Func&lt;Scalar&gt;* u_prev = ext-&gt;fn[0];
  for (int i = 0; i &lt; n; i++)
    result += wt[i] * (lam(u_prev-&gt;val[i]) * (u_prev-&gt;dx[i] * v-&gt;dx[i] + u_prev-&gt;dy[i] * v-&gt;dy[i])
                       - heat_src(e-&gt;x[i], e-&gt;y[i]) * v-&gt;val[i]);
  return result;
}</pre>
</div>
<p>Notice that the basis function <img class="math" src="../../_images/math/42628ab5952aa041b3649af187c7f256cfb4fe9d.png" alt="v_j"/> and the test function
<img class="math" src="../../_images/math/85ffd98b4eaea58a8db38fd0047e3a1d7c5661a0.png" alt="v_i"/> are entering the weak forms via the parameters u and v, respectively (same as for linear
problems). The user does not have to
take care about their indices <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i"/> and <img class="math" src="../../_images/math/8122aa89ea6e80784c6513d22787ad86e36ad0cc.png" alt="j"/>, this is handled by Hermes outside the weak forms.</p>
<p>The code snippet above also shows how values and derivatives of the solution <img class="math" src="../../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u"/> can be accessed via
the ExtData structure, and the coordinates of the integration points via the Geom structure.
The contents of ExtData is user-defined and the Geom structure contains geometrical information
including the unit normal and tangential vectors to the boundary at the integration points
(also for curved boundaries). See the file
<a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/src/forms.h">src/forms.h</a> for more details.</p>
<p>The Newton&#8217;s method always has to start from an initial condition, and in this example
this is</p>
<div class="highlight-python"><pre>// Initial condition. It will be projected on the FE mesh
// to obtain initial coefficient vector for the Newton's method.
scalar init_cond(double x, double y, double&amp; dx, double&amp; dy)
{
  dx = 0;
  dy = 0;
  return INIT_COND_CONST;
}</pre>
</div>
<p>The weak forms are registered as usual, except that the previous solution u_prev
is passed into the form as an extra argument:</p>
<div class="highlight-python"><pre>// Previous solution for the Newton's iteration.
Solution u_prev;

// Initialize the weak formulation.
WeakForm wf;
wf.add_matrix_form(callback(jac), H2D_UNSYM, H2D_ANY, &amp;u_prev);
wf.add_vector_form(callback(res), H2D_ANY, &amp;u_prev);</pre>
</div>
<p>Recall that by H2D_UNSYM we declare that the Jacobian bilinear form is not symmetric,
and by H2D_ANY that the form should be used for elements with any material marker.</p>
<p>The NonlinSystem class is initialized in the same way as LinSystem:</p>
<div class="highlight-python"><pre>// Initialize the linear system.
NonlinSystem nls(&amp;wf, &amp;space);</pre>
</div>
<p>An important step in the Newton&#8217;s method that cannot be skipped is the projection
of the initial condition on the FE space. This is where the initial coefficient
vector <img class="math" src="../../_images/math/46ef8ab42c68496eb7e5027f6f2b961bca5e3af5.png" alt="\bfY_0"/> for the Newton&#8217;s iteration is created:</p>
<div class="highlight-python"><pre>// Project the function init_cond() on the FE space
// to obtain initial coefficient vector for the Newton's method.
info("Projecting initial condition to obtain initial vector for the Newton'w method.");
nls.project_global(init_cond, &amp;u_prev);</pre>
</div>
<p>The method project_global() has an optional third argument which is the projection
norm. Its default value is H2D_DEFAULT_PROJ_NORM = 1 (<img class="math" src="../../_images/math/ee500eed1910756eedebc53f0079d3aaf7a5753f.png" alt="H^1"/> norm). Other
admissible values are 0 (<img class="math" src="../../_images/math/07c3de5211dc08b13546363f8b139700a16dd963.png" alt="L^2"/> norm), 2 (<img class="math" src="../../_images/math/d015ab117f4c71f12005755e60a077278cd306ec.png" alt="Hcurl"/> norm) and 3 (<img class="math" src="../../_images/math/668dcbe361338eb7374da6eff016bb0ffacf9498.png" alt="Hdiv"/> norm) whose
use will be shown later. Later we&#8217;ll also see how to handle the projection for PDE systems.</p>
<p>The Newton&#8217;s iteration is done using the method solve_newton():</p>
<div class="highlight-python"><pre>// Perform Newton's iteration.
info("Performing Newton's iteration.");
bool verbose = true; // Default is false.
if (!nls.solve_newton(&amp;u_prev, NEWTON_TOL, NEWTON_MAX_ITER, verbose))
  error("Newton's method did not converge.");</pre>
</div>
<p>If the optional parameter &#8220;verbose&#8221; is set to &#8220;true&#8221;, convergence
information is printed.</p>
<p>Note that arbitrary Filters can be passed as additional optional parameters.
This will be shown in the tutorial example
<a class="reference external" href="http://hpfem.org/hermes2d/doc/src/tutorial-3.html#flame-propagation-problem-19">19-timedep-flame</a>.
Results for this example are shown below.</p>
<p>Approximate solution <img class="math" src="../../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u"/> for <img class="math" src="../../_images/math/72d3c250b11b1ced112b6ded38a52f36627aae9d.png" alt="\alpha = 2"/>:</p>
<div align="center" class="align-center"><img alt="result for alpha = 2" class="align-center" src="../../_images/newton-ellipt-1-2.png" style="width: 600px; height: 400px;" /></div>
<p>Approximate solution <img class="math" src="../../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u"/> for <img class="math" src="../../_images/math/12c4d3592caf594ac713bf9df6abfd11c68601fc.png" alt="\alpha = 4"/>:</p>
<div align="center" class="align-center"><img alt="result for alpha = 4" class="align-center" src="../../_images/newton-ellipt-1-4.png" style="width: 600px; height: 400px;" /></div>
</div>
<div class="section" id="general-initial-condition-16">
<h2>General Initial Condition (16)<a class="headerlink" href="#general-initial-condition-16" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/16-newton-elliptic-2">16-newton-elliptic-2</a>.</p>
<p>We will solve the nonlinear model problem from the previous section again,</p>
<div class="math">
<p><img src="../../_images/math/a437ea6567ffda93f36ec10e50e3467b4e323d41.png" alt="-\nabla \cdot (\lambda(u)\nabla u) - f(x,y) = 0 \ \ \ \mbox{in } \Omega = (-10,10)^2" /></p>
</div><p>but now with nonhomogeneous Dirichlet boundary conditions</p>
<div class="math">
<p><img src="../../_images/math/d23b24252d7c1506dd7e867419e2c210e1173c30.png" alt="u(x, y) = (x+10)(y+10)/100 \ \ \ \mbox{on } \partial \Omega" /></p>
</div><p>and with a general initial guess init_guess(x,y).</p>
<p>The treatment of the Dirichlet boundary conditions in the code looks as follows:</p>
<div class="highlight-python"><pre>// This function is used to define Dirichlet boundary conditions.
double dir_lift(double x, double y, double&amp; dx, double&amp; dy) {
  dx = (y+10)/10.;
  dy = (x+10)/10.;
  return (x+10)*(y+10)/100.;
}

// Boundary condition types.
BCType bc_types(int marker)
{
  return BC_ESSENTIAL;
}

// Essential (Dirichlet) boundary condition values.
scalar essential_bc_values(int ess_bdy_marker, double x, double y)
{
  double dx, dy;
  return dir_lift(x, y, dx, dy);
}</pre>
</div>
<p>The initial condition has the form:</p>
<div class="highlight-python"><pre>// Initial condition. It will be projected on the FE mesh
// to obtain initial coefficient vector for the Newton's method.
scalar init_cond(double x, double y, double&amp; dx, double&amp; dy)
{
  // Using the Dirichlet lift elevated by two
  double val = dir_lift(x, y, dx, dy) + 2;
  return val;
}</pre>
</div>
<p>The initial condition must be projected on the finite element space
in order to obtain the initial coefficient vector <img class="math" src="../../_images/math/46ef8ab42c68496eb7e5027f6f2b961bca5e3af5.png" alt="\bfY_0"/> for the Newton&#8217;s
iteration:</p>
<div class="highlight-python"><pre>// Project the function init_cond() on the FE space
// to obtain initial coefficient vector for the Newton's method.
info("Projecting initial condition to obtain initial vector for the Newton'w method.");
nls.project_global(init_cond, &amp;u_prev);</pre>
</div>
<p>Recall that the vector <img class="math" src="../../_images/math/46ef8ab42c68496eb7e5027f6f2b961bca5e3af5.png" alt="\bfY_0"/> can be retrieved from the NonLinSystem
class using the method get_solution_vector().</p>
<p>The following figure shows the <img class="math" src="../../_images/math/ee500eed1910756eedebc53f0079d3aaf7a5753f.png" alt="H^1"/>-projection of the initial condition init_cond():</p>
<div align="center" class="align-center"><img alt="H1 projection" class="align-center" src="../../_images/proj-h1.png" style="width: 600px; height: 350px;" /></div>
<p>The Newton&#8217;s iteration is again performed using</p>
<div class="highlight-python"><pre>// Perform Newton's iteration.
info("Performing Newton's iteration.");
bool verbose = true; // Default is false.
if (!nls.solve_newton(&amp;u_prev, NEWTON_TOL, NEWTON_MAX_ITER, verbose))
  error("Newton's method did not converge.");</pre>
</div>
<p>The converged solution looks as follows:</p>
<div align="center" class="align-center"><img alt="approximate solution" class="align-center" src="../../_images/solution6.png" style="width: 600px; height: 350px;" /></div>
</div>
<div class="section" id="newton-s-method-and-adaptivity-17">
<h2>Newton&#8217;s Method and Adaptivity (17)<a class="headerlink" href="#newton-s-method-and-adaptivity-17" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/17-newton-elliptic-adapt">17-newton-elliptic-adapt</a>.</p>
<p>We will still keep the simple model problem</p>
<div class="math">
<p><img src="../../_images/math/7016b81ffbc75b03cbc5d9ef29eee1acba6ef54e.png" alt="-\nabla \cdot (\lambda(u)\nabla u) - f(x,y) = 0 \ \ \ \mbox{in } \Omega = (-10,10)^2," /></p>
</div><p>equipped with nonhomogeneous Dirichlet boundary conditions</p>
<div class="math">
<p><img src="../../_images/math/293a4ef9b2a0bdd4f47577e692476385f5faa6cc.png" alt="u(x, y) = (x+10)(y+10)/100 \ \ \ \mbox{on } \partial \Omega," /></p>
</div><p>but this time it will be solved using automatic adaptivity. As usual in Hermes, adaptivity
will be guided by the difference between a coarse and fine mesh approximations. At the beginning,
the initial condition is projected on the coarse mesh:</p>
<div class="highlight-python"><pre>// Project the function init_cond() on the FE space
// to obtain initial coefficient vector for the Newton's method.
info("Projecting initial condition to obtain initial vector on coarse mesh.");
nls.project_global(init_cond, &amp;u_prev);</pre>
</div>
<p>Then we solve the nonlinear problem on the coarse mesh and store
the coarse mesh solution:</p>
<div class="highlight-python"><pre>// Newton's loop on the coarse mesh.
info("Solving on coarse mesh.");
bool verbose = true; // Default is false.
if (!nls.solve_newton(&amp;u_prev, NEWTON_TOL_COARSE, NEWTON_MAX_ITER, verbose))
  error("Newton's method did not converge.");

// Store the result in sln_coarse.
sln_coarse.copy(&amp;u_prev);</pre>
</div>
<p>Note that storing the solution u_prev in sln_coarse is equivalent to storing the
converged coefficient vector <img class="math" src="../../_images/math/d167f8d47d3012af4957943108f085f8d117e8dc.png" alt="\bfY"/>, but the Solution can be passed into weak
forms.</p>
<p>Next a refinement selector is initialized:</p>
<div class="highlight-python"><pre>// Initialize a refinement selector.
H1ProjBasedSelector selector(CAND_LIST, CONV_EXP, H2DRS_DEFAULT_ORDER);</pre>
</div>
<p>Then the nonlinear problem on the fine mesh is initialized and the initial
coefficient vector <img class="math" src="../../_images/math/46ef8ab42c68496eb7e5027f6f2b961bca5e3af5.png" alt="\bfY_0"/> on the fine mesh is calculated:</p>
<div class="highlight-python"><pre>// Initialize the fine mesh problem.
RefSystem rnls(&amp;nls);

// Set initial condition for the Newton's method on the fine mesh.
if (as == 1) {
  info("Projecting coarse mesh solution to obtain initial vector on new fine mesh.");
  rnls.project_global(&amp;sln_coarse, &amp;u_prev);
}
else {
  info("Projecting fine mesh solution to obtain initial vector on new fine mesh.");
  rnls.project_global(&amp;sln_fine, &amp;u_prev);
}</pre>
</div>
<p>Notice that we only use sln_coarse as the initial guess on the fine mesh
in the first adaptivity step when we do not have any fine mesh solution yet,
otherwise a projection of the last fine mesh solution is used.</p>
<p>Note that the procedure explained here is what we typically do and the reader
does not have to follow it. It is possible to start the Newton&#8217;s method on the
fine mesh using zero or any other initial condition.</p>
<p>Next we perform the Newton&#8217;s loop on the fine mesh and store the result in
sln_fine:</p>
<div class="highlight-python"><pre>// Newton's loop on the fine mesh.
info("Solving on fine mesh.");
if (!rnls.solve_newton(&amp;u_prev, NEWTON_TOL_FINE, NEWTON_MAX_ITER, verbose))
  error("Newton's method did not converge.");

// Store the fine mesh solution in sln_fine.
sln_fine.copy(&amp;u_prev);</pre>
</div>
<p>Now we have the solution pair to guide automatic adaptivity, and we can calculate
the error estimate:</p>
<div class="highlight-python"><pre>// Calculate element errors and total error estimate.
info("Calculating error.");
H1Adapt hp(&amp;nls);
hp.set_solutions(&amp;sln_coarse, &amp;sln_fine);
err_est = hp.calc_error() * 100;</pre>
</div>
<p>After adapting the mesh, we must not forget to calculate a new initial coefficient
vector <img class="math" src="../../_images/math/46ef8ab42c68496eb7e5027f6f2b961bca5e3af5.png" alt="\bfY_0"/> on the new coarse mesh. This can be done either by just projecting
the fine mesh solution onto the new coarse mesh, or by solving (in addition to that)
the nonlinear problem on the new coarse mesh:</p>
<div class="highlight-python"><pre>// If err_est too large, adapt the mesh.
if (err_est &lt; ERR_STOP) done = true;
else {
  info("Adapting coarse mesh.");
  done = hp.adapt(&amp;selector, THRESHOLD, STRATEGY, MESH_REGULARITY);
  if (nls.get_num_dofs() &gt;= NDOF_STOP) {
    done = true;
    break;
  }

  // Project the fine mesh solution on the new coarse mesh.
  if (SOLVE_ON_COARSE_MESH)
    info("Projecting fine mesh solution to obtain initial vector on new coarse mesh.");
  else
    info("Projecting fine mesh solution on coarse mesh for error calculation.");
  nls.project_global(&amp;sln_fine, &amp;u_prev);

  if (SOLVE_ON_COARSE_MESH) {
    // Newton's loop on the new coarse mesh.
    info("Solving on coarse mesh.");
    if (!nls.solve_newton(&amp;u_prev, NEWTON_TOL_COARSE, NEWTON_MAX_ITER, verbose))
      error("Newton's method did not converge.");
  }

  // Store the result in sln_coarse.
  sln_coarse.copy(&amp;u_prev);</pre>
</div>
<p>In our experience, the Newton&#8217;s loop on the new coarse mesh can be skipped since this
does not affect convergence and one saves some CPU time. This is illustrated in the
following convergence comparison:</p>
<p>Convergence in the number of DOF (with and without Newton solve on the new coarse mesh):</p>
<div align="center" class="align-center"><img alt="DOF convergence graph for tutorial example 17." class="align-center" src="../../_images/conv_dof_compar2.png" style="width: 600px; height: 400px;" /></div>
<p>Convergence in CPU time (with and without Newton solve on coarse mesh):</p>
<div align="center" class="align-center"><img alt="CPU convergence graph for tutorial example 17." class="align-center" src="../../_images/conv_cpu_compar2.png" style="width: 600px; height: 400px;" /></div>
<p>In the following we show the resulting meshes (corresponding to
SOLVE_ON_COARSE_MESH = false). The solution itself is not
shown since the reader knows it from the previous example.</p>
<p>Resulting coarse mesh.</p>
<div align="center" class="align-center"><img alt="coarse mesh" class="align-center" src="../../_images/mesh_coarse.png" style="width: 500px; height: 400px;" /></div>
<p>Resulting fine mesh.</p>
<div align="center" class="align-center"><img alt="fine mesh" class="align-center" src="../../_images/mesh_fine.png" style="width: 500px; height: 400px;" /></div>
</div>
<div class="section" id="nonlinear-parabolic-problem-18">
<h2>Nonlinear Parabolic Problem (18)<a class="headerlink" href="#nonlinear-parabolic-problem-18" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/18-newton-timedep-heat">18-newton-timedep-heat</a>.</p>
<p>We will employ the Newton&#8217;s method to solve a nonlinear parabolic PDE discretized
in time by the implicit Euler method. To keep things simple, our model problem is
a time-dependent version of the nonlinear equation used in the previous three sections,</p>
<div class="math">
<p><img src="../../_images/math/e1f09b4cbfc9111cf2d3c68f54ab6770ecfdcbac.png" alt="\frac{\partial u}{\partial t} -\nabla \cdot (\lambda(u)\nabla u) - f(x,y) = 0." /></p>
</div><p>We prescribe nonhomogeneous Dirichlet boundary conditions</p>
<div class="math">
<p><img src="../../_images/math/293a4ef9b2a0bdd4f47577e692476385f5faa6cc.png" alt="u(x, y) = (x+10)(y+10)/100 \ \ \ \mbox{on } \partial \Omega," /></p>
</div><p>and the same function is used to define the initial condition. The
problem will be solved in the square <img class="math" src="../../_images/math/a685e9c137558280fe18d9352694f5338136974d.png" alt="\Omega = (-10,10)^2"/> and time interval <img class="math" src="../../_images/math/534cdf04e28f75af33a2c686c136307969e260b2.png" alt="(0, T)"/>.</p>
<p>The weak formulation of the time-discretized problem reads</p>
<div class="math">
<p><img src="../../_images/math/6fc4a734f3d347af8e7d39b3c62e23f6f681eca9.png" alt="\int_{\Omega} \frac{u^{n+1} - u^n}{\tau}v + \lambda(u^{n+1})\nabla u^{n+1}\cdot \nabla v - fv\, \mbox{d}x\mbox{d}y = 0," /></p>
</div><p>where the indices <img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n"/> and <img class="math" src="../../_images/math/0e3efd9b14723a92c2ae891fe27780d5f8e2b215.png" alt="n+1"/> indicate the previous and new time level, respectively. Hence in each
time step we need to solve a <em>time-independent</em> nonlinear problem, and this is something we learned
in the previous sections. The weak forms for the Newton&#8217;s method from the previous sections only
need to be enhanced with a simple term containing the time step <img class="math" src="../../_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau"/> (called TAU):</p>
<div class="highlight-python"><pre>// Jacobian matrix.
template&lt;typename Real, typename Scalar&gt;
Scalar jac(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  Scalar result = 0;
  Func&lt;Scalar&gt;* u_prev_newton = ext-&gt;fn[0];
  for (int i = 0; i &lt; n; i++)
    result += wt[i] * (u-&gt;val[i] * v-&gt;val[i] / TAU + dlam_du(u_prev_newton-&gt;val[i]) * u-&gt;val[i] *
                       (u_prev_newton-&gt;dx[i] * v-&gt;dx[i] + u_prev_newton-&gt;dy[i] * v-&gt;dy[i])
                       + lam(u_prev_newton-&gt;val[i]) * (u-&gt;dx[i] * v-&gt;dx[i] + u-&gt;dy[i] * v-&gt;dy[i]));
  return result;
}</pre>
</div>
<p>Here the function u_prev_newton plays the role of u_prev from the previous sections - this is the
previous solution inside the Newton&#8217;s iteration. Note that the previous time level solution
<img class="math" src="../../_images/math/292a206403c44be137a56e14cfc01788c0ee895a.png" alt="u^n"/> that we call u_prev_time is not present in the Jacobian matrix. It is used in the residual only:</p>
<div class="highlight-python"><pre>// Fesidual vector.
template&lt;typename Real, typename Scalar&gt;
Scalar res(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  Scalar result = 0;
  Func&lt;Scalar&gt;* u_prev_newton = ext-&gt;fn[0];
  Func&lt;Scalar&gt;* u_prev_time = ext-&gt;fn[1];
  for (int i = 0; i &lt; n; i++)
    result += wt[i] * ((u_prev_newton-&gt;val[i] - u_prev_time-&gt;val[i]) * v-&gt;val[i] / TAU +
                      lam(u_prev_newton-&gt;val[i]) * (u_prev_newton-&gt;dx[i] * v-&gt;dx[i] + u_prev_newton-&gt;dy[i] * v-&gt;dy[i])
                       - heat_src(e-&gt;x[i], e-&gt;y[i]) * v-&gt;val[i]);
  return result;
}</pre>
</div>
<p>Note that the function u_prev_newton evolves during the Newton&#8217;s iteration
but the previous time level solution u_prev_time only is updated after the time step
is finished. The weak forms are registered as usual:</p>
<div class="highlight-python"><pre>// Initialize the weak formulation.
WeakForm wf;
wf.add_matrix_form(callback(jac), H2D_UNSYM, H2D_ANY, &amp;u_prev_newton);
wf.add_vector_form(callback(res), H2D_ANY, Tuple&lt;MeshFunction*&gt;(&amp;u_prev_newton, &amp;u_prev_time));</pre>
</div>
<p>The entire time-stepping loop (minus visualization) looks as follows:</p>
<div class="highlight-python"><pre>// Time stepping loop:
double current_time = 0.0;
int t_step = 1;
do {
  info("---- Time step %d, t = %g s.", t_step, current_time); t_step++;

  // Newton's method.
  info("Performing Newton's method.");
  bool verbose = true; // Default is false.
  if (!nls.solve_newton(&amp;u_prev_newton, NEWTON_TOL, NEWTON_MAX_ITER, verbose))
    error("Newton's method did not converge.");

  // Update previous time level solution.
  u_prev_time.copy(&amp;u_prev_newton);

  // Update time.
  current_time += TAU;

} while (current_time &lt; T_FINAL);</pre>
</div>
<p>The stationary solution is not shown here since we already saw it
in the previous sections.</p>
</div>
<div class="section" id="flame-propagation-problem-19">
<h2>Flame Propagation Problem (19)<a class="headerlink" href="#flame-propagation-problem-19" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/19-newton-timedep-flame">19-newton-timedep-flame</a>.</p>
<p>We will employ the Newton&#8217;s method to solve a nonlinear system of two parabolic equations
describing a very simple flame propagation model (laminar flame, no fluid mechanics involved).
The computational domain shown below contains in the middle a narrow portion (cooling rods)
whose purpose is to slow down the chemical reaction:</p>
<div align="center" class="align-center"><img alt="computational domain" class="align-center" src="../../_images/domain7.png" style="width: 760px;" /></div>
<p>The equations for the temperature <img class="math" src="../../_images/math/2554b6496c3b678897e9b060ef00aa9f0a7d7ece.png" alt="T"/> and species concentration <img class="math" src="../../_images/math/ce58e4af225c93d08606c26554caaa5ae32edeba.png" alt="Y"/> have the form</p>
<div class="math">
<p><img src="../../_images/math/9e3ad29a5f3753b695a6548c59c0efbaeffd6253.png" alt="\frac{\partial T}{\partial t} - \Delta T = \omega(T, Y),\\
\frac{\partial Y}{\partial t} - \frac{1}{Le}\Delta Y = -\omega(T, Y)." /></p>
</div><p>Boundary conditions are Dirichlet <img class="math" src="../../_images/math/1277a7b531b016ef04a6921e11362b16a39d7fd9.png" alt="T = 1"/> and <img class="math" src="../../_images/math/33cc402150215e241bfeca836abbc9c8e71a006d.png" alt="Y = 0"/> on the inlet,
Newton <img class="math" src="../../_images/math/2103e7c794addbdbb8c3fcf37f722c5be9216f79.png" alt="\partial T/\partial n = - \kappa T"/> on the cooling rods,
and Neumann <img class="math" src="../../_images/math/ae93b60e7fe5ae3fc7b39f760cf98354be3b9a15.png" alt="\partial T/\partial n = 0"/>, <img class="math" src="../../_images/math/d9faccb71a862bc2451ad6ad4916bf64eec814d6.png" alt="\partial Y/\partial n = 0"/> elsewhere.
The objective of the computation is to obtain the <em>reaction rate</em> defined
by the Arrhenius law,</p>
<div class="math">
<p><img src="../../_images/math/1c15e6d13b069403fbe949a274722ea0054bdc09.png" alt="\omega(T, Y) = \frac{\beta^2}{2{\rm Le}} Y e^{\frac{\beta(T - 1)}{1 + \alpha(T-1)}}." /></p>
</div><p>Here <img class="math" src="../../_images/math/10f32377ac67d94f764f12a15ea987e88c85d3e1.png" alt="\alpha"/> is the gas expansion coefficient in a flow with nonconstant density,
<img class="math" src="../../_images/math/fdb63b9e51abe6bbb16acfb5d7b773ddbb5bf4a8.png" alt="\beta"/> the non-dimensional activation energy, and
<img class="math" src="../../_images/math/7b4b75a9d59cc56911523e11cdc928174f681e68.png" alt="\rm Le"/> the Lewis number (ratio of diffusivity of heat and diffusivity
of mass). Both <img class="math" src="../../_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/>, <img class="math" src="../../_images/math/d96fa38591ed55e52621efd0e72f8290eab95405.png" alt="0 \le \theta \le 1"/> and
<img class="math" src="../../_images/math/ce58e4af225c93d08606c26554caaa5ae32edeba.png" alt="Y"/>, <img class="math" src="../../_images/math/b82003289d55e45d6987b49ecccdd962563b605b.png" alt="0 \le Y \le 1"/> are dimensionless and so is the time <img class="math" src="../../_images/math/e0d2bf360290fd61d1c1557e763f2622363b3d35.png" alt="t"/>.</p>
<p>Time integration is performed using a second-order implicit BDF formula</p>
<div class="math">
<p><img src="../../_images/math/62da28cd90f56591b78df8b87044db62a112d65c.png" alt="T^{n+1} = -\frac{1}{2} T_1^{n+1} + \frac{3}{2} T_2^{n+1},\\
Y^{n+1} = -\frac{1}{2} Y_1^{n+1} + \frac{3}{2} Y_2^{n+1}," /></p>
</div><p>that is obtained using a combination of the following two first-order methods:</p>
<div class="math">
<p><img src="../../_images/math/bffaf564d4d79a14cb4ebdbc7cae36058da4e758.png" alt="\frac{T_1^{n+1} - T^{n}}{\tau} = \Delta T_1^{n+1} + \omega(T_1^{n+1}, Y_1^{n+1}),\\
\frac{Y_1^{n+1} - Y^{n}}{\tau} = \frac{1}{\rm Le} \ \Delta Y_1^{n+1} - \omega(\theta_1^{n+1}, Y_1^{n+1})," /></p>
</div><p>and</p>
<div class="math">
<p><img src="../../_images/math/a6d6559eddfe3927a5188833271a06c2f3a1d6f8.png" alt="\frac{T_2^{n+1} - T^{n}}{\tau} = \frac{2}{3}\left(\Delta T_2^{n+1} + \omega(T_2^{n+1}, Y_2^{n+1})\right) +                                            \frac{1}{3}\left(\Delta T_2^{n} + \omega(T_2^{n}, Y_2^{n})\right),\\
\frac{Y_2^{n+1} - Y^{n}}{\tau} = \frac{2}{3}\left(\frac{1}{\rm Le}\ \Delta Y_2^{n+1} - \omega(T_2^{n+1}, Y_2^{n+1})\right) +
                                    \frac{1}{3}\left(\frac{1}{\rm Le}\ \Delta Y_2^{n} - \omega(T_2^{n}, Y_2^{n})\right)." /></p>
</div><p>Problem parameters are chosen as</p>
<div class="highlight-python"><pre>// Problem constants
const double Le    = 1.0;
const double alpha = 0.8;
const double beta  = 10.0;
const double kappa = 0.1;
const double x1 = 9.0;</pre>
</div>
<p>It is worth mentioning that the initial conditions for <img class="math" src="../../_images/math/2554b6496c3b678897e9b060ef00aa9f0a7d7ece.png" alt="T"/> and <img class="math" src="../../_images/math/ce58e4af225c93d08606c26554caaa5ae32edeba.png" alt="Y"/>,</p>
<div class="highlight-python"><pre>// Initial conditions.
scalar temp_ic(double x, double y, scalar&amp; dx, scalar&amp; dy)
  { return (x &lt;= x1) ? 1.0 : exp(x1 - x); }

scalar conc_ic(double x, double y, scalar&amp; dx, scalar&amp; dy)
  { return (x &lt;= x1) ? 0.0 : 1.0 - exp(Le*(x1 - x)); }</pre>
</div>
<p>are defined as exact functions:</p>
<div class="highlight-python"><pre>// Set initial conditions.
t_prev_time_1.set_exact(&amp;mesh, temp_ic); c_prev_time_1.set_exact(&amp;mesh, conc_ic);
t_prev_time_2.set_exact(&amp;mesh, temp_ic); c_prev_time_2.set_exact(&amp;mesh, conc_ic);
t_prev_newton.set_exact(&amp;mesh, temp_ic);  c_prev_newton.set_exact(&amp;mesh, conc_ic);</pre>
</div>
<p>Here the pairs of solutions (t_prev_time_1, y_prev_time_1) and (t_prev_time_2, y_prev_time_2)
correspond to the two first-order time-stepping methods described above. and
(t_prev_newton, y_prev_newton) are used to store the previous step approximation
in the Newton&#8217;s method. The reaction rate <img class="math" src="../../_images/math/54d7d48553f4d9e7ab418118607ea324cbfddfda.png" alt="\omega"/> and its derivatives are handled
via Filters:</p>
<div class="highlight-python"><pre>// Define filters for the reaction rate omega.
DXDYFilter omega(omega_fn, &amp;t_prev_newton, &amp;y_prev_newton);
DXDYFilter omega_dt(omega_dt_fn, &amp;t_prev_newton, &amp;y_prev_newton);
DXDYFilter omega_dy(omega_dy_fn, &amp;t_prev_newton, &amp;y_prev_newton);</pre>
</div>
<p>Details on the functions omega_fn, omega_dt_fn, omega_dy_fn and the weak
forms can be found in the file <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/tutorial/19-newton-timedep-flame/forms.cpp">forms.cpp</a>
Here is how we register the weak forms,</p>
<div class="highlight-python"><pre>// Initialize the weak formulation.
WeakForm wf(2);
wf.add_matrix_form(0, 0, callback(newton_bilinear_form_0_0), H2D_UNSYM, H2D_ANY, &amp;omega_dt);
wf.add_matrix_form_surf(0, 0, callback(newton_bilinear_form_0_0_surf), 3);
wf.add_matrix_form(0, 1, callback(newton_bilinear_form_0_1), H2D_UNSYM, H2D_ANY, &amp;omega_dc);
wf.add_matrix_form(1, 0, callback(newton_bilinear_form_1_0), H2D_UNSYM, H2D_ANY, &amp;omega_dt);
wf.add_matrix_form(1, 1, callback(newton_bilinear_form_1_1), H2D_UNSYM, H2D_ANY, &amp;omega_dc);
wf.add_vector_form(0, callback(newton_linear_form_0), H2D_ANY,
                   Tuple&lt;MeshFunction*&gt;(&amp;t_prev_newton, &amp;t_prev_time_1, &amp;t_prev_time_2, &amp;omega));
wf.add_vector_form_surf(0, callback(newton_linear_form_0_surf), 3, &amp;t_prev_newton);
wf.add_vector_form(1, callback(newton_linear_form_1), H2D_ANY,
                   Tuple&lt;MeshFunction*&gt;(&amp;c_prev_newton, &amp;c_prev_time_1, &amp;c_prev_time_2, &amp;omega));</pre>
</div>
<p>The nonlinear system is initialized as follows:</p>
<div class="highlight-python"><pre>// Initialize the nonlinear system.
NonlinSystem nls(&amp;wf, Tuple&lt;Space*&gt;(&amp;tspace, &amp;cspace));</pre>
</div>
<p>The initial coefficient vector <img class="math" src="../../_images/math/46ef8ab42c68496eb7e5027f6f2b961bca5e3af5.png" alt="\bfY_0"/> for the Newton&#8217;s method is calculated
by projecting the initial conditions on the FE spaces:</p>
<div class="highlight-python"><pre>// Project temp_ic() and conc_ic() onto the FE spaces to obtain initial
// coefficient vector for the Newton's method.
info("Projecting initial conditions to obtain initial vector for the Newton'w method.");
nls.project_global(Tuple&lt;MeshFunction*&gt;(&amp;t_prev_newton, &amp;c_prev_newton),
                   Tuple&lt;Solution*&gt;(&amp;t_prev_newton, &amp;c_prev_newton));</pre>
</div>
<p>The time stepping loop looks as follows, notice the visualization of <img class="math" src="../../_images/math/54d7d48553f4d9e7ab418118607ea324cbfddfda.png" alt="\omega"/>
through a DXDYFilter:</p>
<div class="highlight-python"><pre>// Time stepping loop:
double current_time = 0.0; int ts = 1;
do {
  info("---- Time step %d, t = %g s.", ts, current_time);

  // Newton's method.
  info("Performing Newton's iteration.");
  bool verbose = true; // Default is false.
  if (!nls.solve_newton(Tuple&lt;Solution*&gt;(&amp;t_prev_newton, &amp;c_prev_newton), NEWTON_TOL, NEWTON_MAX_ITER, verbose,
                        Tuple&lt;MeshFunction*&gt;(&amp;omega, &amp;omega_dt, &amp;omega_dc))) error("Newton's method did not converge.");

  // Visualization.
  DXDYFilter omega_view(omega_fn, &amp;t_prev_newton, &amp;c_prev_newton);
  rview.set_min_max_range(0.0,2.0);
  char title[100];
  sprintf(title, "Reaction rate, t = %g", current_time);
  rview.set_title(title);
  rview.show(&amp;omega_view);

  // Update current time.
  current_time += TAU;

  // Store two time levels of previous solutions.
  t_prev_time_2.copy(&amp;t_prev_time_1);
  c_prev_time_2.copy(&amp;c_prev_time_1);
  t_prev_time_1.copy(&amp;t_prev_newton);
  c_prev_time_1.copy(&amp;c_prev_newton);

  ts++;
} while (current_time &lt;= T_FINAL);</pre>
</div>
<p>A few snapshots of the reaction rate <img class="math" src="../../_images/math/54d7d48553f4d9e7ab418118607ea324cbfddfda.png" alt="\omega"/> at various times are shown below:</p>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol11.png" style="width: 800px;" /></div>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol21.png" style="width: 800px;" /></div>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol31.png" style="width: 800px;" /></div>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol41.png" style="width: 800px;" /></div>
</div>
<div class="section" id="navier-stokes-equations-20">
<h2>Navier-Stokes Equations (20)<a class="headerlink" href="#navier-stokes-equations-20" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/20-newton-timedep-ns">20-newton-timedep-ns</a>.</p>
<p>In this example, the time-dependent laminar incompressible Navier-Stokes equations are
discretized in time via the implicit Euler method. If NEWTON == true,
the Newton&#8217;s method is used to solve the nonlinear problem at each time
step. If NEWTON == false, the convective term only is linearized using the
velocities from the previous time step. Obviously the latter approach is wrong,
but people do this frequently because it is faster and simpler to implement.
Therefore we include this case for comparison purposes. We also show how
to use discontinuous (<img class="math" src="../../_images/math/07c3de5211dc08b13546363f8b139700a16dd963.png" alt="L^2"/>) elements for pressure and thus make the
velocity discreetely divergence free. Comparison to approximating the
pressure with the standard (continuous) Taylor-Hood elements is shown.</p>
<p>The computational domain is a rectangular channel containing a
circular obstacle:</p>
<div align="center" class="align-center"><img alt="computational domain" class="align-center" src="../../_images/domain8.png" style="width: 760px;" /></div>
<p>The circle is defined via NURBS. Its radius and position, as well as some additional
geometry parameters can be changed in the mesh file &#8220;domain.mesh&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">L</span> <span class="o">=</span> <span class="mi">15</span>            <span class="c"># domain length (should be a multiple of 3)</span>
<span class="n">H</span> <span class="o">=</span> <span class="mi">5</span>             <span class="c"># domain height</span>
<span class="n">S1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mi">2</span>          <span class="c"># x-center of circle</span>
<span class="n">S2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mi">2</span>          <span class="c"># y-center of circle</span>
<span class="n">R</span> <span class="o">=</span> <span class="mi">1</span>             <span class="c"># circle radius</span>
<span class="n">A</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="c"># helper length</span>
<span class="n">EPS</span> <span class="o">=</span> <span class="mf">0.10</span>        <span class="c"># vertical shift of the circle</span>
</pre></div>
</div>
<p>The Navier-Stokes equations are assumed in the standard form</p>
<div class="math">
<p><img src="../../_images/math/522bc71b11ad949f99d38a9ee274497e997a362b.png" alt="\frac{\partial \bfv}{\partial t} - \frac{1}{Re}\Delta \bfv + (\bfv \cdot \nabla) \bfv + \nabla p = 0,\\
\mbox{div} \bfv = 0," /></p>
</div><p>where <img class="math" src="../../_images/math/b35129db80c5b109c118dca74844e89fa7089929.png" alt="\bfv = (u, v)"/> is the velocity vector, <img class="math" src="../../_images/math/16ef95610462b9c2c03cba4c272fe84208bf3c61.png" alt="Re"/> the Reynolds number, <img class="math" src="../../_images/math/36f73fc1312ee0349b3f3a0f3bd9eb5504339011.png" alt="p"/> the pressure,
and <img class="math" src="../../_images/math/07e24e0234445d77cfd603c3f1f4ff968e0bf67a.png" alt="(\bfv \cdot \nabla) \bfv"/> the nonlinear convective term. We prescribe a parabolic
velocity profile at inlet (the left-most edge). The inlet velocity is time-dependent, it
increases linearly in time from zero to a user-defined value during an initial time period,
and then it stays constant. Standard no-slip velocity boundary conditions are prescribed
on the rest of the boundary with the exception of the outlet (right-most edge) where the
standard &#8220;do nothing&#8221; boundary conditions are prescribed. No boundary conditions are
prescribed for pressure - being an <img class="math" src="../../_images/math/07c3de5211dc08b13546363f8b139700a16dd963.png" alt="L^2"/>-function, the pressure does not
admit any boundary conditions.</p>
<p>The role of the pressure in the Navier-Stokes equations
is interesting and worth a brief discussion. Since the equations only contain its gradient,
it is determined up to a constant. This does not mean that the problem is ill-conditioned
though, since the pressure only plays the role of a Lagrange multiplier that keeps
the velocity divergence-free. More precisely, the better the pressure is resolved,
the closer the approximate velocity to being divergence free. The best one can do
is to approximate the pressure in <img class="math" src="../../_images/math/07c3de5211dc08b13546363f8b139700a16dd963.png" alt="L^2"/> (using discontinuous elements). Not only because
it is more meaningful from the point of view of the weak formulation, but also because
the approximate velocity automatically becomes discreetely divergence-free (integral
of its divergence over every element in the mesh is zero). The standard Taylor-Hood
elements approximating both the velocity and pressure with <img class="math" src="../../_images/math/ee500eed1910756eedebc53f0079d3aaf7a5753f.png" alt="H^1"/>-conforming (continuous)
elements do not have this property and thus are less accurate. We will compare these
two approaches below. Last, the pressure needs to be approximated by elements of
a lower polynomial degree than the velocity in order to satisfy the inf-sup condition.</p>
<p>The time derivative is approximated using the implicit Euler method:</p>
<div class="math">
<p><img src="../../_images/math/3f3a24b524c135f4e63a595f67b4fb586826a544.png" alt="\frac{\bfv^{n+1}}{\tau} - \frac{\bfv^n}{\tau} - \frac{1}{Re}\Delta \bfv^{n+1} + (\bfv^{n+1} \cdot \nabla) \bfv^{n+1} + \nabla p^{n+1} = 0,\\
\mbox{div} \bfv^{n+1} = 0," /></p>
</div><p>where <img class="math" src="../../_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau"/> is the time step. This is a nonlinear problem that involves three equations (two
for velocity components and the continuity equation). Accordingly, we define three spaces:</p>
<div class="highlight-python"><pre>  // Spaces for velocity components and pressure.
  H1Space xvel_space(&amp;mesh, xvel_bc_type, essential_bc_values_xvel, P_INIT_VEL);
  H1Space yvel_space(&amp;mesh, yvel_bc_type, NULL, P_INIT_VEL);
#ifdef PRESSURE_IN_L2
  L2Space p_space(&amp;mesh, P_INIT_PRESSURE);
#else
  H1Space p_space(&amp;mesh, NULL, NULL, P_INIT_PRESSURE);
#endif</pre>
</div>
<p>We also need to define the proper projection norms in these spaces:</p>
<div class="highlight-python"><pre>  // Define projection norms.
  int vel_proj_norm = 1;
#ifdef PRESSURE_IN_L2
  int p_proj_norm = 0;
#else
  int p_proj_norm = 1;
#endif</pre>
</div>
<p>After registering weak forms and initializing the LinSystem and NonlinSystem, if NEWTON == true
we calculate the initial coefficient vector <img class="math" src="../../_images/math/46ef8ab42c68496eb7e5027f6f2b961bca5e3af5.png" alt="\bfY_0"/> for the Newton&#8217;s method:</p>
<div class="highlight-python"><pre>// Project initial conditions on FE spaces to obtain initial coefficient
// vector for the Newton's method.
if (NEWTON) {
  info("Projecting initial conditions to obtain initial vector for the Newton'w method.");
  nls.project_global(Tuple&lt;MeshFunction*&gt;(&amp;xvel_prev_time, &amp;yvel_prev_time, &amp;p_prev_time),
                     Tuple&lt;Solution*&gt;(&amp;xvel_prev_newton, &amp;yvel_prev_newton, &amp;p_prev_newton),
                     Tuple&lt;int&gt;(vel_proj_norm, vel_proj_norm, p_proj_norm));
}</pre>
</div>
<p>Note that when projecting multiple functions, we can use different projection
norms for each.</p>
<p>The time stepping loop looks as follows:</p>
<div class="highlight-python"><pre>// Time-stepping loop:
char title[100];
int num_time_steps = T_FINAL / TAU;
for (int ts = 1; ts &lt;= num_time_steps; ts++)
{
  TIME += TAU;
  info("---- Time step %d, time = %g:", ts, TIME);

  if (NEWTON) {
    if (TIME &lt;= STARTUP_TIME) {
      info("Updating time-dependent essential BC.");
      nls.update_essential_bc_values();
    }
    // Newton's method.
    info("Performing Newton's method.");
    bool verbose = true; // Default is false.
    if (!nls.solve_newton(Tuple&lt;Solution*&gt;(&amp;xvel_prev_newton, &amp;yvel_prev_newton, &amp;p_prev_newton),
                          NEWTON_TOL, NEWTON_MAX_ITER, verbose)) {
      error("Newton's method did not converge.");
    }
  }
  else {
    // Needed if time-dependent essential BC are used.
    if (TIME &lt;= STARTUP_TIME) {
      info("Updating time-dependent essential BC.");
      ls.update_essential_bc_values();
    }
    // Assemble and solve.
    info("Assembling and solving linear problem.");
    ls.assemble();
    ls.solve(Tuple&lt;Solution*&gt;(&amp;xvel_prev_newton, &amp;yvel_prev_newton, &amp;p_prev_newton));
  }</pre>
</div>
<p>The following comparisons demonstrate the effect of using the Newton&#8217;s method, and of using
continuous vs. discontinuous
elements for the pressure. There are three triplets of velocity snapshots. In each one, the images
were obtained with (1) NEWTON == false &amp;&amp; PRESSURE_IN_L2 undefined, (2) NEWTON == true &amp;&amp; PRESSURE_IN_L2
undefined, and (3) NEWTON == true &amp;&amp; PRESSURE_IN_L2 defined. It follows from these comparisons that one
should definitely use the option (3).</p>
<p>Time t = 10 s:</p>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol_no_newton_10.png" style="width: 840px;" /></div>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol_newton_10.png" style="width: 840px;" /></div>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol_l2_newton_10.png" style="width: 840px;" /></div>
<p>Time t = 15 s:</p>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol_no_newton_15.png" style="width: 840px;" /></div>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol_newton_15.png" style="width: 840px;" /></div>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol_l2_newton_15.png" style="width: 840px;" /></div>
<p>Time t = 20 s:</p>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol_no_newton_20.png" style="width: 840px;" /></div>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol_newton_20.png" style="width: 840px;" /></div>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol_l2_newton_20.png" style="width: 840px;" /></div>
<p>Snapshot of a continuous pressure approximation (t = 20 s):</p>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/p_no_newton_20.png" style="width: 840px;" /></div>
<p>Snapshot of a discontinuous pressure approximation (t = 20 s):</p>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/p_l2_newton_20.png" style="width: 840px;" /></div>
</div>
<div class="section" id="gross-pitaevski-equation-21">
<h2>Gross-Pitaevski Equation (21)<a class="headerlink" href="#gross-pitaevski-equation-21" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://git.hpfem.org/hermes.git/tree/HEAD:/hermes2d/tutorial/21-newton-timedep-gp">21-newton-timedep-gp</a>.</p>
<p>In this example we use the Newton&#8217;s method to solve the nonlinear complex-valued
time-dependent Gross-Pitaevski equation. This equation describes the ground state of
a quantum system of identical bosons using the Hartree–Fock approximation and the
pseudopotential interaction model. For time-discretization one can use either
the first-order implicit Euler method or the second-order Crank-Nicolson
method.</p>
<p>The computational domain is the square <img class="math" src="../../_images/math/cb8db917323e1e95e0532c3ba32188cb435fa88f.png" alt="(-1,1)^2"/> and boundary conditions are zero Dirichlet. The equation has the form</p>
<div class="math">
<p><img src="../../_images/math/14531b5b674269cd80082318b4537feae7388abe.png" alt="i\hbar \frac{\partial \psi}{\partial t} = -\frac{\hbar^2}{2m} \Delta \psi + g \psi |\psi|^2 + \frac{m}{2} \omega^2 (x^2 + y^2) \psi" /></p>
</div><p>where <img class="math" src="../../_images/math/e5aba91a00034d9625e607c063601d40a905cf9e.png" alt="\psi(x,y)"/> is the unknown solution (wave function), <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i"/> the complex unit,
<img class="math" src="../../_images/math/0678e85c9374aaebeb3099f934cb8a7e452c75da.png" alt="\hbar"/> the Planck constant, <img class="math" src="../../_images/math/f5047d1e0cbb50ec208923a22cd517c55100fa7b.png" alt="m"/> the mass of the boson,
<img class="math" src="../../_images/math/311cabda3a9b09f0dde217303ca9d1cd9201dcf6.png" alt="g"/> the coupling constant (proportional to the scattering length of two interacting bosons) and
<img class="math" src="../../_images/math/54d7d48553f4d9e7ab418118607ea324cbfddfda.png" alt="\omega"/> the frequency.</p>
<p>From the implementation point of view, the only detail worth mentioning is the
use of the complex version of Hermes in the file <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/tutorial/19-newton-timedep-gp/CMakeLists.txt">CMakeLists.txt</a>:</p>
<div class="highlight-python"><pre># use the complex version of the library:
set(HERMES ${HERMES_CPLX_BIN})</pre>
</div>
<p>The weak forms can be found in the file <a class="reference external" href="http://git.hpfem.org/hermes.git/blob/HEAD:/hermes2d/tutorial/19-newton-timedep-gp/forms.cpp">forms.cpp</a>:</p>
<div class="highlight-python"><pre>// Residuum for the implicit Euler time discretization
template&lt;typename Real, typename Scalar&gt;
Scalar F_euler(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  scalar ii = cplx(0.0, 1.0);  // imaginary unit, ii^2 = -1

  Scalar result = 0;
  Func&lt;Scalar&gt;* psi_prev_newton = ext-&gt;fn[0];
  Func&lt;Scalar&gt;* psi_prev_time = ext-&gt;fn[1];
  for (int i = 0; i &lt; n; i++)
    result += wt[i] * (ii * H * (psi_prev_newton-&gt;val[i] - psi_prev_time-&gt;val[i]) * v-&gt;val[i] / TAU
            - H*H/(2*M) * (psi_prev_newton-&gt;dx[i] * v-&gt;dx[i] + psi_prev_newton-&gt;dy[i] * v-&gt;dy[i])
            - G * psi_prev_newton-&gt;val[i] *  psi_prev_newton-&gt;val[i] * conj(psi_prev_newton-&gt;val[i]) * v-&gt;val[i]
            - .5*M*OMEGA*OMEGA * (e-&gt;x[i] * e-&gt;x[i] + e-&gt;y[i] * e-&gt;y[i]) * psi_prev_newton-&gt;val[i] * v-&gt;val[i]);

  return result;
}

// Jacobian for the implicit Euler time discretization
template&lt;typename Real, typename Scalar&gt;
Scalar J_euler(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  scalar ii = cplx(0.0, 1.0);  // imaginary unit, ii^2 = -1

  Scalar result = 0;
  Func&lt;Scalar&gt;* psi_prev_newton = ext-&gt;fn[0];
  for (int i = 0; i &lt; n; i++)
    result += wt[i] * (ii * H * u-&gt;val[i] * v-&gt;val[i] / TAU
                     - H*H/(2*M) * (u-&gt;dx[i] * v-&gt;dx[i] + u-&gt;dy[i] * v-&gt;dy[i])
                     - 2* G * u-&gt;val[i] *  psi_prev_newton-&gt;val[i] * conj(psi_prev_newton-&gt;val[i]) * v-&gt;val[i]
                     - G * psi_prev_newton-&gt;val[i] * psi_prev_newton-&gt;val[i] * u-&gt;val[i] * v-&gt;val[i]
                     - .5*M*OMEGA*OMEGA * (e-&gt;x[i] * e-&gt;x[i] + e-&gt;y[i] * e-&gt;y[i]) * u-&gt;val[i] * v-&gt;val[i]);
  return result;
}

// Residuum for the Crank-Nicolson method
template&lt;typename Real, typename Scalar&gt;
Scalar F_cranic(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  scalar ii = cplx(0.0, 1.0);  // imaginary unit, ii^2 = -1

  Scalar result = 0;
  Func&lt;Scalar&gt;* psi_prev_newton = ext-&gt;fn[0];
  Func&lt;Scalar&gt;* psi_prev_time = ext-&gt;fn[1];
  for (int i = 0; i &lt; n; i++)
    result += wt[i] * (ii * H * (psi_prev_newton-&gt;val[i] - psi_prev_time-&gt;val[i]) * v-&gt;val[i] / TAU
            - 0.5*H*H/(2*M) * (psi_prev_newton-&gt;dx[i] * v-&gt;dx[i] + psi_prev_newton-&gt;dy[i] * v-&gt;dy[i])
            - 0.5*H*H/(2*M) * (psi_prev_time-&gt;dx[i] * v-&gt;dx[i] + psi_prev_time-&gt;dy[i] * v-&gt;dy[i])
            - 0.5*G * psi_prev_newton-&gt;val[i] *  psi_prev_newton-&gt;val[i] * conj(psi_prev_newton-&gt;val[i]) * v-&gt;val[i]
            - 0.5*G * psi_prev_time-&gt;val[i] *  psi_prev_time-&gt;val[i] * conj(psi_prev_time-&gt;val[i]) * v-&gt;val[i]
            - 0.5*0.5*M*OMEGA*OMEGA * (e-&gt;x[i] * e-&gt;x[i] + e-&gt;y[i] * e-&gt;y[i]) * (psi_prev_newton-&gt;val[i] + psi_prev_time-&gt;val[i]) * v-&gt;val[i]);

  return result;
}

// Jacobian for the Crank-Nicolson method
template&lt;typename Real, typename Scalar&gt;
Scalar J_cranic(int n, double *wt, Func&lt;Scalar&gt; *u_ext[], Func&lt;Real&gt; *u, Func&lt;Real&gt; *v, Geom&lt;Real&gt; *e, ExtData&lt;Scalar&gt; *ext)
{
  scalar ii = cplx(0.0, 1.0);  // imaginary unit, ii^2 = -1

  Scalar result = 0;
  Func&lt;Scalar&gt;* psi_prev_newton = ext-&gt;fn[0];
  for (int i = 0; i &lt; n; i++)
    result += wt[i] * (ii * H * u-&gt;val[i] * v-&gt;val[i] / TAU
                     - 0.5*H*H/(2*M) * (u-&gt;dx[i] * v-&gt;dx[i] + u-&gt;dy[i] * v-&gt;dy[i])
                     - 0.5*2* G * u-&gt;val[i] *  psi_prev_newton-&gt;val[i] * conj(psi_prev_newton-&gt;val[i]) * v-&gt;val[i]
                     - 0.5*G * psi_prev_newton-&gt;val[i] *  psi_prev_newton-&gt;val[i] * u-&gt;val[i] * v-&gt;val[i]
                     - 0.5*.5*M*OMEGA*OMEGA * (e-&gt;x[i] * e-&gt;x[i] + e-&gt;y[i] * e-&gt;y[i]) * u-&gt;val[i] * v-&gt;val[i]);
  return result;
}</pre>
</div>
<p>The way the weak forms are registered is standard:</p>
<div class="highlight-python"><pre>// Initialize the weak formulation.
WeakForm wf;
if(TIME_DISCR == 1) {
  wf.add_matrix_form(callback(jacobian_euler), H2D_UNSYM, H2D_ANY, &amp;Psi_prev_newton);
  wf.add_vector_form(callback(residual_euler), H2D_ANY, Tuple&lt;MeshFunction*&gt;(&amp;Psi_prev_newton, &amp;Psi_prev_time));
}
else {
  wf.add_matrix_form(callback(jacobian_cranic), H2D_UNSYM, H2D_ANY, &amp;Psi_prev_newton);
  wf.add_vector_form(callback(residual_cranic), H2D_ANY, Tuple&lt;MeshFunction*&gt;(&amp;Psi_prev_newton, &amp;Psi_prev_time));
}</pre>
</div>
<p>Also the time stepping loop and the call to the Newton&#8217;s method
will not surprize a reader who made it this far in the tutorial:</p>
<div class="highlight-python"><pre>// Time stepping loop:
int nstep = (int)(T_FINAL/TAU + 0.5);
for(int ts = 1; ts &lt;= nstep; ts++)
{

  info("---- Time step %d:", ts);

  // Newton's method.
  info("Performing Newton's method.");
  bool verbose = true; // Default is false.
  if (!nls.solve_newton(&amp;Psi_prev_newton, NEWTON_TOL, NEWTON_MAX_ITER, verbose))
    error("Newton's method did not converge.");

  // Copy result of the Newton's iteration into Psi_prev_time.
  Psi_prev_time.copy(&amp;Psi_prev_newton);
}</pre>
</div>
<p>Sample solution snapshots are shown below:</p>
<p>Snapshot 1:</p>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol_1.png" style="width: 600px;" /></div>
<p>Snapshot 2:</p>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol_2.png" style="width: 600px;" /></div>
<p>Snapshot 3:</p>
<div align="center" class="align-center"><img alt="solution" class="align-center" src="../../_images/sol_3.png" style="width: 600px;" /></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">Hermes2D Tutorial: Part III (Nonlinear Problems)</a><ul>
<li><a class="reference external" href="#the-newton-s-method">The Newton&#8217;s Method</a><ul>
<li><a class="reference external" href="#a-remark-on-the-linear-case">A remark on the linear case</a></li>
</ul>
</li>
<li><a class="reference external" href="#constant-initial-condition-15">Constant Initial Condition (15)</a></li>
<li><a class="reference external" href="#general-initial-condition-16">General Initial Condition (16)</a></li>
<li><a class="reference external" href="#newton-s-method-and-adaptivity-17">Newton&#8217;s Method and Adaptivity (17)</a></li>
<li><a class="reference external" href="#nonlinear-parabolic-problem-18">Nonlinear Parabolic Problem (18)</a></li>
<li><a class="reference external" href="#flame-propagation-problem-19">Flame Propagation Problem (19)</a></li>
<li><a class="reference external" href="#navier-stokes-equations-20">Navier-Stokes Equations (20)</a></li>
<li><a class="reference external" href="#gross-pitaevski-equation-21">Gross-Pitaevski Equation (21)</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="tutorial-2.html"
                                  title="previous chapter">Hermes2D Tutorial: Part II (Automatic Adaptivity)</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="tutorial-4.html"
                                  title="next chapter">Hermes2D Tutorial: Part IV (Adaptivity for Time-Dependent Problems)</a></p>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial-4.html" title="Hermes2D Tutorial: Part IV (Adaptivity for Time-Dependent Problems)"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial-2.html" title="Hermes2D Tutorial: Part II (Automatic Adaptivity)"
             >previous</a> |</li>
        <li><a href="../../index.html">Content</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, hp-FEM group at UNR.
      Last updated on Nov 11, 2010.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  </body>
</html>